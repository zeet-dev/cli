directive @enforceUserAction(action: UserAction!) on FIELD_DEFINITION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

"""
The @specifiedBy built-in directive is used within the type system definition
language to provide a scalar specification URL for specifying the behavior of
custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR

type AcceleratorSpec {
  type: String
  count: Int
  tpuTfVersion: String
}

input AcceleratorSpecInput {
  type: String!
  count: Int!
  tpuTfVersion: String
}

input AddAWSAccountInput {
  userID: UUID!
  accountID: String!
}

input AddCDNInput {
  id: UUID!
  provider: CDNProvider!
  domains: [String!]
}

input AddClusterInput {
  userID: UUID!
  kubeconfig: Upload
  awsAccountID: UUID
  gcpAccountID: UUID
  name: String
  region: String
}

input AddContainerRegistryInput {
  userID: UUID!
  name: String!
  registry: String!
  username: String!
  password: String!
}

input AddCoreWeaveAccountInput {
  userID: UUID!
  kubeconfig: Upload
}

input AddDOAccountInput {
  userID: UUID!
  accessToken: String!
}

input AddGCPAccountInput {
  userID: UUID!
  projectID: String!
  credentials: Upload!
}

input AddLinodeAccountInput {
  userID: UUID!
  accessToken: String!
}

input AddProjectCollaboratorInput {
  id: ID!
  user: String!
  role: ProjectCollaboratorRole!
}

input AddRepoCustomDomainInput {
  id: UUID!
  domain: String!
}

input AddTeamMemberInput {
  id: UUID!
  username: String
  userID: UUID
  role: TeamMemberRole!
}

type APIKey {
  id: UUID!
  token: String!
  name: String!
  description: String!
  createdAt: Time!
}

input AttachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

type AttachedAwsIamPolicy {
  arn: String!
  policyName: String!
  groupName: String!
}

type Autoscaling {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTrigger!]
}

input AutoscalingInput {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTriggerInput!]
}

type AutoscalingTrigger {
  type: AutoscalingType!
  spec: YAML!
}

input AutoscalingTriggerInput {
  type: AutoscalingType!
  spec: YAML!
}

enum AutoscalingType {
  CPU
  MEMORY
  PROMETHEUS
  CUSTOM
}

type AWSAccount {
  id: UUID!
  name: String!
  state: AWSAccountState!
  connected: Boolean
  accountID: String
  roleARN: String
  cloudFormationURL: String!
  cloudFormationReadOnlyURL: String!
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  iamUsers: [AwsUser!]
  userIamConnections: [UserIamConnection!]
  awsIamPolicies: [AwsIamPolicy!]
  awsPolicyJson(input: awsPolicyJsonInput!): AwsPolicyJson
  cloudQuery: CloudQueryService
  costs(input: AwsCostsInput!): [AwsCostItem!]!
  costsByService(input: AwsCostsByServiceInput!): [GroupedAwsCostItem!]!
  savingsPlanRecommendations(input: SavingsPlanRecommendationsInput!): SavingsPlanRecommendation
  rightSizingRecommendations: [RightSizingRecommendation!]
  awsResources(input: AwsResourceSearchInput): AwsResourcesOutput!
  networks: [Network!]
}

enum AWSAccountState {
  WAITING
  SUCCESS
  ERROR
}

type AwsCostItem {
  timePeriod: TimePeriod!
  total: AwsCostTotal!
}

input AwsCostsByServiceInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
  services: [String!]!
}

input AwsCostsInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
}

type AwsCostTotal {
  amount: String!
  unit: String!
}

type AwsIamPolicy {
  arn: String!
  policyName: String!
  awsAccountId: String!
}

type AWSLambda {
  id: UUID!
  name: String!
  region: String
  awsAccount: AWSAccount
  arn: String
  apiGatewayUrl: String
}

type AWSLinks {
  cloudformation: String
  lambda: String
  apiGateway: String
  cloudwatchMetrics: String
  cloudwatchLogs: String
  eks: String
  rds: String
  ec2: String
  vpc: String
  iam: String
}

type AwsPolicyJson {
  awsPolicyJson: JSON!
}

input awsPolicyJsonInput {
  arn: String
  username: String
  policyName: String
}

type AwsResource {
  arn: String!
  type: String!
  region: String
}

input AwsResourceSearchInput {
  region: String
  tag: String
  nextToken: String
}

type AwsResourcesOutput {
  awsResources: [AwsResource!]
  nextToken: String
}

type AwsServiceCostItem {
  service: String!
  total: AwsCostTotal!
}

type AwsUser {
  arn: String!
  userId: String!
  username: String!
  awsAccountId: String!
  attachedAwsPolicies: [AttachedAwsIamPolicy]!
}

input BranchInput {
  active: Boolean
}

type Build {
  id: UUID!
  state: BuildState!
  image: String
  version: String
  errorMessage: String
  logs: Logs
  metrics(name: String!): [Metric!]
  backend: String
  buildID: String
  createdAt: Time!
  updatedAt: Time!
}

input BuildLogsInput {
  deploymentID: ID!
  after: String
}

type BuildMethod {
  name: String!
  type: BuildType!
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  staticPath: String
  runCommand: String
  releaseCommand: String
  nodejsVersion: String
}

type BuildStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
  build: Build
}

enum BuildState {
  BUILD_STARTING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
}

enum BuildType {
  DOCKER
  BUILDPACKS
  PYTHON
  PYTHON_DJANGO
  NODE
  NODE_STATIC
  NODE_NEXTJS
  UBUNTU
  ELIXIR_PHOENIX
  GOLANG_MODULES
  HEROKUISH
}

type CDN {
  id: UUID!
  provider: CDNProvider!
  domains: [CDNDomain!]
  state: String!
  origin: String
  endpoint: String
  certificate: Certificate
}

type CDNDomain {
  domain: String!
  certReady: Boolean
  routeReady: Boolean
  instruction: DNSRecord
}

enum CDNProvider {
  AWS_CLOUDFRONT
}

type Certificate {
  provider: CertificateProivder
  dnsNames: [String!]
  issuing: Boolean!
  ready: Boolean!
  challenges: [CertificateChallenge!]
  instructions: [DNSRecord!]
  createdAt: Time!
  updatedAt: Time!
}

type CertificateChallenge {
  dnsName: String!
  type: String!
  solver: String!
  wildcard: Boolean!
  statusReason: String!
  statusState: String!
}

enum CertificateProivder {
  CERT_MANAGER
  AWS_ACM
}

input CheckPriceInput {
  teamId: UUID
  source: RepoSourceType
  installation: ID
  owner: String
  repo: String
  dockerImage: String
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  cpu: String
  gpu: String
  memory: String
  dedicated: Boolean
}

type CheckPriceOutput {
  total: PriceComponent!
  subTotal: PriceComponent!
  cpu: PriceComponent!
  memory: PriceComponent!
  gpu: PriceComponent!
  volumes: PriceComponent!
  bandwidth: PriceComponent!
  misc: PriceComponent!
  canBeFreeTier: Boolean!
}

input CheckProjectNameInput {
  name: String!
}

interface CISource {
  name: String!
  owner: String!
  url: URL!
  description: String
}

union CloudAccount = AWSAccount | GCPAccount | DOAccount | LinodeAccount

enum CloudAccountState {
  WAITING
  SUCCESS
  ERROR
}

enum CloudProvider {
  UNKNOWN
  ZEET
  AWS
  AZURE
  GCP
  ALIBABA
  OCI
  IBM
  TENCENT
  DO
  COREWEAVE
  OVH
  LINODE
  VULTR
  SCALEWAY
}

type CloudQueryService {
  state: CloudQueryState!
  id: UUID!
}

enum CloudQueryState {
  READY
  ERROR
  CREATING
  DELETING
}

type CloudResource {
  resourceType: CloudResourceType!
  id: String!
  shared: Boolean!
  region: String!
}

enum CloudResourceType {
  Machine
  Disk
  LoadBalancer
  VPC
  Cluster
}

type CloudRuntime {
  cloud: CloudAccount
  region: String
  awsLambda: String
  awsFargate: String
  gcpCloudRun: String
  azureApp: String
}

type Cluster {
  id: UUID!
  name: String!
  region: String
  state: ClusterState!
  private: Boolean!
  connected: Boolean
  cloudProvider: CloudProvider
  clusterProvider: ClusterProvider
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  doAccount: DOAccount
  cwAccount: CoreWeaveAccount
  linodeAccount: LinodeAccount
  cloudAccount: CloudAccount
  namespace: String
  domain: String
  ingressIP: String
  ingressDNS: String
  clusterIssuers: [String!]
  prometheus: Prometheus
  grafana: Grafana
  staticIPs: [String!]
  kubeconfig: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistry: ContainerRegistry
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  network: Network
  machines: [Machine!]
}

type ClusterDomains {
  id: ID!
  cluster: Cluster!
  domains: [CustomDomain!]
  cdns: [CDN!]
}

enum ClusterProvider {
  GENERIC
  EKS
  GKE
  DOKS
  COREWEAVE
  LKE
}

enum ClusterState {
  PENDING
  CREATING
  HEALTHY
  DELETING
  ERROR
  ERROR_DELETING
}

input ConnectUserToIamInput {
  userID: UUID!
  awsIamArn: String
  awsAccountId: String
}

type Container {
  id: UUID!
  status: ContainerStatus!
}

type ContainerRegistry {
  id: UUID!
  name: String!
  registry: String!
  username: String
  credentialProvider: ContainerRegistryCredentialProvider
}

enum ContainerRegistryCredentialProvider {
  DOCKER
  ECR
  GCR
  DOCR
}

type ContainerResourcesSpec {
  cpu: Float
  memory: Float
  ephemeralStorage: Float
  accelerator: AcceleratorSpec
  spot: Boolean
}

input ContainerResourcesSpecInput {
  cpu: Float!
  memory: Float!
  ephemeralStorage: Float
  accelerator: AcceleratorSpecInput
  spot: Boolean
}

type ContainerSpec {
  cpu: Float
  memory: Float
  gpu: Float
}

type ContainerStatus {
  scheduled: Boolean!
  running: Boolean!
  ready: Boolean!
}

type CoreWeaveAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  namespace: String
  connected: Boolean
  clusters: [Cluster!]
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type Cost {
  service: String
  unblendedCostAmount: Float
  unblendedCostUnit: String
  periodStart: String
  periodEnd: String
}

input CostByServiceWhere {
  services: [String!]!
}

input CostUsageWhere {
  granularity: String!
  dimensionType1: String!
  dimensionType2: String!
  dimension2NotIn: [String!]!
  dimension1In: [String!]!
}

input CreateAPIKeyInput {
  userID: UUID!
  name: String!
}

input CreateClusterInput {
  userID: UUID!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  name: String!
  region: String!
}

input CreateDatabaseInput {
  userID: UUID!
  name: String!
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: DatabaseDeployTargetInput!
  engine: DatabaseEngineType!
  version: String!
  options: DatabaseOptions
}

input CreateDatadogIntegrationInput {
  userID: UUID!
  apiKey: String!
}

input CreateIPFSServiceInput {
  userID: UUID!
  name: String!
  awsAccountID: UUID!
  clusterID: UUID!
}

input CreateProjectDockerInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: ProjectDeployInput
  dockerImage: String!
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  dedicated: Boolean
  gpu: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectEnvironmentInput {
  projectID: UUID!
  name: String!
  repos: [UUID!]
}

input CreateProjectFromProjectTemplateInput {
  id: ID!
  deployTarget: ProjectDeployInput
  envs: [EnvVarInput!]
}

input CreateProjectGitInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  url: String!
  deployTarget: ProjectDeployInput
  build: ProjectBuildInput
  deployService: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: [PortInput!]
  volumes: [VolumeInput!]
  replication: [ReplicationInput!]
  runCommand: String
  logShipper: LogShipperInput
  deployStrategy: DeployStrategy
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  clusterIssuerName: String
  hostNetwork: Boolean
  staticIP: Boolean
  nodeSelector: JSON
  noBuildCache: Boolean
  kanikoFlags: KanikoFlagsInput
  datadogApmEnabled: Boolean
  enabled: Boolean
  path: String
}

input CreateProjectHelmInput {
  userID: UUID!
  projectID: UUID
  environmentName: String
  environmentID: UUID
  name: String!
  deployTarget: ProjectDeployInput!
  namespace: String
  releaseName: String!
  repository: String
  chart: String
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  values: String
  valuesRef: String
  enabled: Boolean
}

input CreateProjectInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  installation: ID!
  owner: String!
  repo: String!
  deployTarget: ProjectDeployInput
  deployService: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  dedicated: Boolean
  gpu: String
  buildCommand: String
  buildType: String
  runCommand: String
  staticPath: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectsFromTemplateInput {
  id: ID!
  userID: UUID
  name: String
  projects: [CreateProjectFromProjectTemplateInput!]
}

input CreateProjectTerraformInput {
  userID: UUID!
  name: String!
  deployTarget: ProjectDeployInput!
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  variables: JSON
  envs: [EnvVarInput!]
  terraformVersion: String
  manualApproval: Boolean
  enabled: Boolean
}

input CreateProjectV2Input {
  userID: UUID!
  name: String!
}

input CreateTeamInput {
  name: String!
  login: String
  billingEmail: String!
  avatar: String
  paymentMethod: String
  tier: PlanTier
  billingPeriod: PlanBillingPeriod
}

input CreateWeb3ChallengeInput {
  address: String!
}

input CreateWebhookIntegrationInput {
  userID: UUID!
  url: String!
}

type CustomDomain {
  id: ID!
  domain: String!
  cnameTargets: [String!]
  ipTargets: [String!]
  isApex: Boolean!
  disableCertManager: Boolean
  instructions: [DNSRecord!]
  certificate: Certificate
}

input DatabaseDeployTargetInput {
  provider: DatabaseProviderType!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  clusterID: UUID
}

enum DatabaseEngineType {
  POSTGRES
  MYSQL
  MONGODB
  REDIS
  KAFKA
  NATS
}

type DatabaseLink {
  id: UUID!
  repo: Repo!
  database: Repo!
  envPrefix: String
  envs: [EnvVar!]!
}

input DatabaseOptions {
  username: String
  password: String
  database: String
}

enum DatabaseProviderType {
  AWS_RDS
  GCP_CLOUD_SQL
  DO_DATABASE
  DOCKER
}

type DatadogIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiKey: String
}

type DatadogLogIntegration {
  key: String!
}

input DatadogLogIntegrationInput {
  key: String!
}

type Deployment {
  id: ID!
  description: String
  version: String!
  status: DeploymentStatus!
  endpoints: [String!]
  privateEndpoint: String
  loadBalancers: [LoadBalancer!]
  errorMessage: String
  branch: String
  build: Build
  release: Release
  deployStep: PipelineStep
  buildStage: BuildStage
  testStage: PipelineStage
  releaseStage: PipelineStage
  deployStage: PipelineStage
  deleteStage: PipelineStage
  logs: [LogEntry!]
  repo: Repo
  deployStatus: DeployStatus
  containers: [Container!]
  metrics(name: String!): [Metric!]
  volumes: [Volume!]
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  githubLinks: GithubLinks
  helmRelease: HelmRelease
  dataOut: String
  createdAt: Time!
  updatedAt: Time!
  events: [Event!]!
  runtime: Runtime
  terraformOperation: TerraformOperation
}

type DeploymentConnection {
  totalCount: Int!
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

input DeploymentsInput {
  first: Int = 10
  after: String
  branch: String
}

enum DeploymentStatus {
  BUILD_PENDING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
  DEPLOY_PENDING
  DEPLOY_IN_PROGRESS
  RELEASE_IN_PROGRESS
  DEPLOY_FAILED
  DEPLOY_SUCCEEDED
  BUILD_ABORTED
  DEPLOY_STOPPED
  DEPLOY_HEALHTY
  DEPLOY_CRASHING
}

input DeployRepoBranchInput {
  id: UUID!
  branch: String!
}

type DeployStatus {
  active: Boolean!
  publicIPs: [String!]
  state: String!
  replicas: Int!
  runningReplicas: Int!
  readyReplicas: Int!
  errorMessage: String
}

enum DeployStrategy {
  RESTART
  ROLLING
  CANARY
  BLUE_GREEN
  RED_BLACK
}

enum DeployTarget {
  KUBERNETES
  SERVERLESS
  TERRAFORM
  PULUMI
  AWS_SAM
  AWS_CDK
  AWS_CLOUDFORMATION
  GCP_CLOUD_RUN
}

input DetachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

enum DisableReason {
  FREE_TRIAL_ENDED
  USER_ACTION
  PAYMENT_ERROR
  USER_BANNED
}

type DiscordIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type DiscordWebhookIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
}

type DNSRecord {
  name: String
  domain: String!
  type: DNSRecordType!
  value: String
}

enum DNSRecordType {
  A
  CNAME
  TXT
}

type DOAccount {
  id: UUID!
  name: String!
  state: DOAccountState!
  accessTokenPrefix: String
  defaultProject: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum DOAccountState {
  WAITING
  SUCCESS
  ERROR
}

type DockerImage {
  id: ID!
  tag: String!
  digest: String!
  repository: DockerRepository!
}

type DockerRepository implements CISource {
  id: ID!
  name: String!
  owner: String!
  url: URL!
  isPrivate: Boolean!
  description: String
  images: [DockerImage!]
  image(tag: String!): DockerImage
  ports: [Port!]
  volumes: [VolumeSpec!]
}

input DuplicateProjectInput {
  id: UUID!
  enabled: Boolean!
  name: String!
  projectID: UUID
  environmentName: String
  environmentID: UUID
}

input DuplicateRepoInput {
  repoID: UUID!
  name: String!
  environmentID: UUID!
}

type EnvVar {
  id: ID!
  name: String!
  value: String!
  visible: Boolean!
  sealed: Boolean!
  source: EnvVarSource
  createdAt: Time!
  updatedAt: Time!
}

input EnvVarInput {
  name: String!
  value: String!
  sealed: Boolean
}

type EnvVarSource {
  type: EnvVarSourceType!
}

enum EnvVarSourceType {
  ZEET
  PROJECT
  ENVIRONMENT
  CLUSTER
  DATABASE
}

type EnvVarTemplate {
  name: String!
  description: String!
  value: String
  generator: String
  reference: String
  required: Boolean!
  locked: Boolean!
  hidden: Boolean!
  options: [String!]
}

enum ErrorCode {
  CardDeclined
  NoContainers
  NeedAuth
  NeedPaymentDetails
  NoActiveBuildMethodError
  NoDockerfilePresent
  NoPortsExposed
  InternalServerError
}

type Event {
  id: String!
  type: EventType!
  message: String!
  source: String!
  count: Int!
  lastSeenAt: Time!
}

enum EventType {
  INFO
  WARNING
  ERROR
}

type GCPAccount {
  id: UUID!
  name: String!
  state: GCPAccountState!
  error: String
  connected: Boolean
  projectID: String
  clientEmail: String
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum GCPAccountState {
  WAITING
  SUCCESS
  ERROR
}

type GCPLinks {
  deploymentManager: String
  cloudFunctions: String
  cloudFunctionsTrigger: String
  cloudRun: String
  cloudMonitoring: String
  cloudLogging: String
  gke: String
}

type GitBranch {
  id: ID!
  name: String!
  commit: GitCommit!
}

type GitCommit {
  id: ID!
  oid: String!
  abbreviatedOid: String!
  message: String!
  createdAt: Time!
}

input GithubConnectionInput {
  apiUrl: URL
  installation: String!
  owner: String!
  repo: String!
}

type GitHubInstallation {
  id: ID!
  appID: Int!
  account: GitHubUser!
  repositorySelection: String!
  repositories: [GitHubRepository!]
}

type GithubLinks {
  commitURL: String
}

type GitHubRepoIntegration {
  id: UUID!
  githubConnectionID: Int
  githubRepository: GitHubRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

input GitHubRepoIntegrationInput {
  githubConnectionID: Int
  githubOwner: String
  githubName: String
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  autoStopPullRequest: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

type GitHubRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
  buildMethodSuggestions: [BuildMethod!]
  serverless: ServerlessConfig
  ports: [Port!]
  volumes: [VolumeSpec!]
}

type GitHubUser {
  id: ID!
  login: String!
  avatar: URL
  type: GithubUserType!
}

enum GithubUserType {
  User
  Organization
}

enum GitProvider {
  GITHUB
  GITLAB
  BITBUCKET
}

interface GitRepository {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

input GPUInput {
  type: String
  count: Int!
}

type GPUSpec {
  type: String
  count: Int!
}

type Grafana {
  url: String!
  user: String
  password: String
}

type GroupedAwsCostItem {
  timePeriod: TimePeriod!
  groups: [AwsServiceCostItem!]!
}

type HelmChart {
  id: String!
  repository: HelmRepository!
  name: String
  normalized_name: String
  description: String
  logoImage: String
  stars: Int
  version: String
  app_version: String
  deprecated: Boolean
}

type HelmChartConnection {
  totalCount: Int!
  nodes: [HelmChart!]!
  pageInfo: PageInfo!
}

type HelmRelease {
  id: String!
  chart: HelmChart!
  version: String!
}

type HelmRepository {
  id: String!
  url: String
  name: String
  organization_name: String
  chart(name: String!): HelmChart!
}

type HTTPProbe {
  host: String
  port: String!
  path: String
}

interface Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

enum IntegrationType {
  SLACK
  SLACK_WEBHOOK
  DISCORD
  DISCORD_WEBHOOK
  DATADOG
}

input InviteTeamMemberInput {
  id: UUID!
  role: TeamMemberRole!
  email: String
  expiresAt: Time
}

type IPFSService {
  id: UUID!
  owner: User!
  state: IPFSServiceState!
  cluster: Cluster
  accessToken: String
  apiURL: String
  nodeURL: String
  api: Project
}

enum IPFSServiceState {
  CREATING
  HEALTHY
  DELETING
  ERROR
}

interface IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type JobRun {
  id: UUID!
  state: JobRunState!
  command: String!
  exitCode: Int
  logs: Logs
  metrics(name: String!): [Metric!]
  createdAt: Time
  build: Build
  project: Repo
}

type JobRunConnection {
  totalCount: Int!
  nodes: [JobRun!]!
  pageInfo: PageInfo!
}

enum JobRunState {
  JOB_RUN_STARTING
  JOB_RUN_RUNNING
  JOB_RUN_FAILED
  JOB_RUN_SUCCEEDED
}

scalar JSON

type KanikoFlags {
  compressedCaching: Boolean
}

input KanikoFlagsInput {
  compressedCaching: Boolean
}

type KubernetesCustomization {
  nodeSelector: MapString
  hostNetwork: Boolean
  serviceAccountName: String
  podAnnotations: MapString
  serviceAnnotations: MapString
  ingressAnnotations: MapString
  clusterIssuerName: String
}

input KubernetesCustomizationInput {
  nodeSelector: JSON
  hostNetwork: Boolean
  podAnnotations: JSON
  serviceAnnotations: JSON
  ingressAnnotations: JSON
  clusterIssuerName: String
}

type KubernetesRuntime {
  cluster: Cluster
  region: String
}

type KubernetesSecretMount {
  secretName: String!
  mountPath: String!
  readOnly: Boolean!
}

input KubernetesSecretMountInput {
  secretName: String!
  mountPath: String!
}

input LinkCloudToClusterInput {
  cloudType: CloudProvider!
  cloudId: UUID!
  clusterID: UUID!
  cloudAZ: String
  cloudRegion: String
}

input LinkDatabaseInput {
  id: UUID!
  databaseID: UUID!
  envPrefix: String
}

type LinodeAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  accessTokenPrefix: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type LoadBalancer {
  name: String!
  dns: [String!]!
  ips: [String!]!
  ports: [Int!]
}

type LogDNAIntegration {
  key: String!
}

input LogDNAIntegrationInput {
  key: String!
}

type LogEntry {
  text: String!
  timestamp: Time
}

type Logs {
  id: ID!
  cursor: String
  completed: Boolean!
  entries: [LogEntry!]
}

type LogShipper {
  type: LogShipperType!
  logz: LogzIntegration
  syslog: SyslogIntegration
  logDNA: LogDNAIntegration
  datadog: DatadogLogIntegration
}

input LogShipperInput {
  type: LogShipperType
  logz: LogzIntegrationInput
  syslog: SyslogIntegrationInput
  logDNA: LogDNAIntegrationInput
  datadog: DatadogLogIntegrationInput
}

enum LogShipperType {
  LOGZIO
  SYSLOG
  LOGDNA
  DATADOG
}

type LogzIntegration {
  token: String!
  url: String
}

input LogzIntegrationInput {
  token: String!
  url: String!
}

type Machine {
  id: ID!
  name: String!
  region: String!
  data: JSON
  network: Network
  cluster: Cluster
  projects(input: ProjectsInput): ProjectConnection
}

scalar Map

scalar MapString

type Metric {
  timestamp: Time!
  value: Float
}

input MoveRepoInput {
  id: UUID!
  projectID: UUID
  environmentName: String
  environmentID: UUID
  name: String
}

type Mutation {
  enableRepo(id: ID!): Repo!
  disableRepo(id: ID!): Repo!
  deleteRepo(id: ID!): Boolean!
  buildRepo(id: ID!, branch: String, noCache: Boolean): Repo!
  abortBuild(id: UUID!): Repo!
  deployRepo(id: ID!): Repo!
  deployRepoBranch(input: DeployRepoBranchInput!): Repo!
  setRepoEnvs(input: SetRepoEnvsInput!): Repo!
  setPaymentMethod(paymentMethod: String!): User!
  copyEnvVars(from: ID!, to: ID!): Repo
  addProjectCollaborator(input: AddProjectCollaboratorInput!): Repo!
  removeProjectCollaborator(id: ID!): Repo!
  transferProject(input: TransferProjectInput!): Repo!
  createAPIKey(input: CreateAPIKeyInput): APIKey!
  deleteAPIKey(id: UUID!): Boolean!
  addAWSAccount(input: AddAWSAccountInput!): AWSAccount!
  verifyAWSAccount(id: UUID!): AWSAccount!
  removeAWSAccount(id: UUID!): Boolean!
  connectUserToIam(input: ConnectUserToIamInput!): Boolean!
  disconnectUserFromIam(id: UUID!): Boolean!
  attachAwsPolicyToUser(input: AttachAwsPolicyToUser!): Boolean!
  detachAwsPolicyToUser(input: DetachAwsPolicyToUser!): Boolean!
  updateBranch(input: UpdateBranchInput!): RepoBranchV2!
  addCDN(input: AddCDNInput!): CDN!
  updateCDN(input: UpdateCDNInput!): CDN!
  removeCDN(id: UUID!): Boolean!
  invalidateCDNCache(id: UUID!): CDN!
  ensureCloudqueryEnabled(awsAccountId: UUID!): Boolean!
  createCluster(input: CreateClusterInput!): Cluster!
  deleteCluster(id: UUID!): Boolean!
  updateCluster(input: UpdateClusterInput!): Cluster!
  addCluster(input: AddClusterInput!): Cluster!
  linkCloudToCluster(input: LinkCloudToClusterInput!): Cluster!
  updateClusterDomain(input: UpdateClusterDomainInput!): Cluster!
  addContainerRegistry(input: AddContainerRegistryInput!): ContainerRegistry!
  removeContainerRegistry(id: UUID!): Boolean!
  addCoreWeaveAccount(input: AddCoreWeaveAccountInput!): CoreWeaveAccount!
  removeCoreWeaveAccount(id: UUID!): Boolean!
  createDatabase(input: CreateDatabaseInput!): Repo!
  linkDatabase(input: LinkDatabaseInput!): Repo!
  unlinkDatabase(id: UUID!): Boolean
  updateDatabaseLink(input: updateDatabaseLinkInput!): Repo!
  addDOAccount(input: AddDOAccountInput!): DOAccount!
  removeDOAccount(id: UUID!): Boolean!
  addRepoCustomDomain(input: AddRepoCustomDomainInput!): Repo!
  removeRepoCustomDomain(input: RemoveRepoCustomDomainInput!): Repo!
  updateRepoCustomDomain(input: UpdateRepoCustomDomainInput!): Repo!
  reissueCustomDomainCertificate(input: ReissueCustomDomainCertificateInput!): Repo!
  addGCPAccount(input: AddGCPAccountInput!): GCPAccount!
  removeGCPAccount(id: UUID!): Boolean!
  createProjectHelm(input: CreateProjectHelmInput!): Repo!
  createSlackWebhookIntegration(input: CreateWebhookIntegrationInput!): SlackWebhookIntegration!
  updateSlackWebhookIntegration(input: UpdateWebhookIntegrationInput!): SlackWebhookIntegration!
  createDiscordWebhookIntegration(input: CreateWebhookIntegrationInput!): DiscordWebhookIntegration!
  updateDiscordWebhookIntegration(input: UpdateWebhookIntegrationInput!): DiscordWebhookIntegration!
  createDatadogIntegration(input: CreateDatadogIntegrationInput!): DatadogIntegration!
  removeUserIntegration(input: RemoveUserIntegrationInput!): Boolean!
  createIPFSService(input: CreateIPFSServiceInput!): IPFSService!
  runJob(input: RunJobInput!): JobRun!
  addLinodeAccount(input: AddLinodeAccountInput!): LinodeAccount!
  removeLinodeAccount(id: UUID!): Boolean!
  createProjectV2(input: CreateProjectV2Input!): Project!
  updateProjectV2(input: UpdateProjectV2Input!): Project!
  deleteProjectV2(id: UUID!): Boolean!
  createProjectEnvironment(input: CreateProjectEnvironmentInput!): ProjectEnvironment!
  updateProjectEnvironment(input: UpdateProjectEnvironmentInput!): ProjectEnvironment!
  deleteProjectEnvironment(id: UUID!): Boolean!
  moveRepoToProjectEnvironment(input: MoveRepoInput!): Repo!
  duplicateProject(input: DuplicateProjectInput!): Repo!
  duplicateRepo(input: DuplicateRepoInput!): Repo!
  deleteProjectBranch(id: UUID!, branch: String!): Boolean!
  rollbackProjectToDeployment(projectID: UUID!, deploymentID: UUID!): Repo!
  updateProject(input: UpdateProjectInput!): Repo!
  updateProjectDanger(input: UpdateProjectDangerInput!): Repo!
  removeProbe(input: RemoveProbeInput!): Repo!
  removeLogShipper(id: UUID!): Boolean!
  migrateGithubConnection(id: UUID!, installationID: String!): Repo!
  createProject(input: CreateProjectInput!): Repo!
  createProjectDocker(input: CreateProjectDockerInput!): Repo!
  createProjectGit(input: CreateProjectGitInput!): Repo!
  createTeam(input: CreateTeamInput!): Team!
  deleteTeam(id: UUID!): Boolean!
  updateTeam(input: UpdateTeamInput!): Team!
  updateTeamMemberRole(input: UpdateTeamMemberRoleInput!): UserTeamEdge!
  addTeamMember(input: AddTeamMemberInput!): Team!
  removeTeamMember(input: RemoveTeamMemberInput!): Team!
  inviteTeamMember(input: InviteTeamMemberInput!): TeamMemberInvitation!
  acceptTeamMemberInvitation(token: String!): Team!
  resendTeamMemberInvitation(id: UUID!): Boolean!
  deleteTeamMemberInvitation(id: UUID!): Boolean!
  uploadDockerCompose(contents: String!): Template!
  createProjectsFromTemplate(input: CreateProjectsFromTemplateInput!): [Repo!]!
  freezeRepo(id: UUID!): Template!
  createProjectTerraform(input: CreateProjectTerraformInput!): Repo!
  updateUser(input: UpdateUserInput!): User!
  deleteUser: Boolean!
  createWeb3Challenge(input: CreateWeb3ChallengeInput!): Web3Challenge!
  signInWithWeb3(input: SignInWithWeb3Input!): UserAuth!
}

type Network {
  id: ID!
  name: String!
  region: String!
  data: JSON
  cloud: CloudAccount
  clusters: [Cluster!]
  machines: [Machine]
}

type PageInfo {
  startCursor: String!
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PageInput {
  first: Int = 10
  last: Int
  after: String
  before: String
  filter: String
  sort: String
}

type PipelineStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type PipelineStep {
  id: UUID!
  logs: Logs
}

type Plan {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod
  stripeSubscription: StripeSubscription
}

enum PlanBillingPeriod {
  MONTHLY
  ANNUALLY
}

enum PlanTier {
  LEGACY
  BASIC
  PRO
}

type Port {
  port: String!
  protocol: String!
  public: Boolean!
  https: Boolean!
  grpc: Boolean!
  loadBalancer: Boolean!
}

input PortInput {
  port: String!
  protocol: PortProtocol!
  public: Boolean!
  https: Boolean!
  grpc: Boolean
}

enum PortProtocol {
  tcp
  udp
}

type PriceComponent {
  cost: Int!
  explanation: String!
}

type Prices {
  ramGB: Float!
  cpuCore: Float!
  dedicatedGPU: Float!
  dedicatedRamGB: Float!
  dedicatedCpuCore: Float!
  storageGB: Float!
}

type Probe {
  command: String
  http: HTTPProbe
  tcp: TCPProbe
  initialDelaySeconds: Int!
  periodSeconds: Int!
  successThreshold: Int!
  failureThreshold: Int!
  timeoutSeconds: Int!
}

input ProbeInput {
  command: String
  httpEndpoint: String
  tcpEndpoint: String
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  failureThreshold: Int
  timeoutSeconds: Int
}

interface ProfileOwner {
  login: String!
  name: String!
  avatar: URL
}

type Project {
  id: UUID!
  name: String!
  envs: [EnvVar!]
  isMultiRepo: Boolean!
  defaultEnvironment: ProjectEnvironment!
  environment(id: UUID, name: String): ProjectEnvironment!
  environments: [ProjectEnvironment!]!
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  owner: User!
  createdAt: Time!
  updatedAt: Time!
}

input ProjectBuildInput {
  buildType: BuildType
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  nodejsVersion: String
}

type ProjectCollaborator {
  id: ID!
  user: User!
  role: ProjectCollaboratorRole!
}

type ProjectCollaboratorInvitation {
  id: ID!
  email: String!
  link: String!
  role: ProjectCollaboratorRole!
  project: Repo!
}

enum ProjectCollaboratorRole {
  OWNER
  EDITOR
  VIEWER
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge!]!
  nodes: [Project!]!
}

input ProjectDeployInput {
  deployTarget: DeployTarget!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  clusterID: UUID
  region: String
}

type ProjectEdge {
  cursor: String!
  node: Project!
}

type ProjectEnvironment {
  id: UUID!
  name: String!
  envs: [EnvVar!]
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  project: Project
  createdAt: Time!
  updatedAt: Time!
}

interface ProjectOwner {
  projects(input: ProjectsInput): ProjectConnection!
}

input ProjectsInput {
  page: PageInput
}

type ProjectTemplate {
  id: ID!
  name: String!
  description: String!
  image: String!
  source: RepoSource!
  cpu: Float!
  memory: Float!
  envs: [EnvVarTemplate!]
  ports: [Port!]
  replication: [Replication!]
  volumes: [VolumeSpec!]
  gpu: Int
  dedicated: Boolean
}

type Prometheus {
  url: String!
  user: String
  password: String
  token: String
}

type PrometheusScrape {
  path: String!
  port: Int!
}

input PrometheusScrapeInput {
  path: String!
  port: Int!
}

type Query {
  currentUser: User!
  user(id: ID!): User!
  team(id: UUID, path: String): Team
  project(id: UUID, path: String): Project
  repo(id: UUID, path: String): Repo
  dockerRepository(image: String!): DockerRepository
  checkPrice(input: CheckPriceInput!): CheckPriceOutput!
  prices: Prices!
  awsCostByService(awsAccountId: UUID!, where: CostByServiceWhere!): [Cost!]!
  awsCostUsage2(awsAccountId: UUID!, where: CostUsageWhere!): [Cost!]!
  searchHelmCharts(input: SearchHelmChartsInput!): HelmChartConnection!
  helmRepository(url: String!): HelmRepository!
  template(id: UUID, slug: String, url: String): Template!
  terraformRegistry(url: URL): TerraformRegistry!
}

input ReissueCustomDomainCertificateInput {
  id: UUID!
}

type Release {
  id: UUID!
  logs: Logs
}

input RemoveProbeInput {
  id: ID!
  readinessProbe: Boolean
  livenessProbe: Boolean
  startupProbe: Boolean
}

input RemoveRepoCustomDomainInput {
  id: UUID!
  domainID: UUID!
}

input RemoveTeamMemberInput {
  id: UUID!
  userID: UUID!
}

input RemoveUserIntegrationInput {
  userID: UUID!
  id: UUID!
}

type Replication {
  region: String!
  replicas: Int
  cluster: Cluster
}

input ReplicationInput {
  region: String!
  replicas: Int!
  clusterID: UUID
}

type Repo {
  id: ID!
  name: String!
  source: RepoSource!
  appID: String
  enabled: Boolean!
  namespace: String
  kappID: String
  clusterDomains: [ClusterDomains!]
  cdns: [CDN!]
  envs: [EnvVar!]
  replication: [Replication!]
  ports: [Port!]
  volumes: [VolumeSpec!]
  secretMounts: [KubernetesSecretMount!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  buildMethod: BuildMethod
  noBuildCache: Boolean
  kanikoFlags: KanikoFlags
  resources: ContainerResourcesSpec
  buildResources: ContainerResourcesSpec
  branchResources: ContainerResourcesSpec
  serverlessResources: ServerlessResourceSpec
  readinessProbe: Probe
  livenessProbe: Probe
  startupProbe: Probe
  autoscaling: Autoscaling
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  staticIP: Boolean
  deployments(first: Int = 10, after: String, input: DeploymentsInput): [Deployment!]
  deployment(id: ID!): Deployment
  branches: [RepoBranch!]
  branch(id: UUID, name: String): RepoBranchV2
  productionBranchV2: RepoBranchV2
  branchesV2(page: PageInput, input: BranchInput): RepoBranchConnection
  productionBranch: String
  productionDeployment: Deployment
  githubRepository: GitHubRepository
  githubIntegration: GitHubRepoIntegration
  helmChart: HelmChart
  helmValues: String
  terraformVersion: String
  terraformVariables: JSON
  image: String
  collaborators: [ProjectCollaborator!]
  collaboratorInvitations: [ProjectCollaboratorInvitation!]
  free: Boolean
  prometheusScrape: PrometheusScrape
  logShipper: LogShipper
  kubernetesCustomization: KubernetesCustomization
  deployTarget: DeployTarget
  canDeploy: Boolean
  cluster: Cluster
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  awsIamRole: String
  gcpServiceAccount: String
  deployStrategy: DeployStrategy
  deployService: Boolean
  cronJobSchedule: String
  jobRun(id: UUID!): JobRun!
  jobRuns: JobRunConnection
  hasBuildStage: Boolean
  hasDeployStage: Boolean
  containerRegistry: ContainerRegistry
  databaseProvider: DatabaseProviderType
  databaseEngine: DatabaseEngineType
  databaseVersion: String
  databaseLinks: [DatabaseLink!]!
  linkedProjects: [DatabaseLink!]!
  databaseEnvs: [EnvVar!]!
  disableReason: DisableReason
  datadogApmEnabled: Boolean
  project: Project
  projectEnvironment: ProjectEnvironment
  owner: User!
  createdAt: Time!
  updatedAt: Time!
  buildSpec: ContainerSpec
  cpu: String
  memory: String
  gpu: GPUSpec
  tpu: TPUSpec
  ephemeralStorage: Float
  dedicated: Boolean
  deployBranch: Boolean
  branchIgnore: String
  nodeSelector: JSON
  hostNetwork: Boolean
  clusterIssuerName: String
  path: String!
  machines: [Machine!]
}

type RepoBranch {
  id: ID!
  name: String!
  state: String
  updatedAt: Time
  deployments: [Deployment!]
}

type RepoBranchConnection {
  totalCount: Int!
  nodes: [RepoBranchV2!]!
  pageInfo: PageInfo!
}

type RepoBranchV2 {
  id: UUID!
  name: String!
  state: String
  status: String
  environmentSlug: String
  branchSlug: String
  latestDeployment: Deployment
  deployments(page: PageInput): DeploymentConnection
  endpoints: [String!]
  privateEndpoints: [String!]
  loadBalancers: [LoadBalancer!]
  metrics(name: String!): [Metric!]
  image: String
  namespace: String
  kappID: String
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  repo: Repo
  createdAt: Time!
  updatedAt: Time!
  resources: [CloudResource!]
}

input ReposInput {
  first: Int = 10
  after: String
  team: ID
  showDisabled: Boolean = false
}

type RepoSource {
  id: ID!
  type: RepoSourceType!
  name: String!
}

enum RepoSourceType {
  GITHUB
  GITHUB_PUBLIC
  GITLAB
  GIT
  DOCKER
  DOCKER_HUB
  HELM
  TERRAFORM
}

type RightSizingInstance {
  name: String
  monthlyCost: String
  hourlyCost: String
  type: String
  memory: String
  storage: String
  vcpu: String
  utilization: RightSizingUtilization
  resourceId: String
}

type RightSizingRecommendation {
  currentInstance: RightSizingInstance
  recommendations: [RightSizingRecommendationDetail!]
  reasons: [String!]!
}

type RightSizingRecommendationDetail {
  estimatedMonthlyCost: String
  estimatedMonthlySavings: String
  platformDifferences: [String]
  instance: RightSizingInstance
}

type RightSizingUtilization {
  maxCpuUtilizationPercentage: String
  maxMemoryUtilizationPercentage: String
  maxStorageUtilizationPercentage: String
}

input RunJobInput {
  id: UUID!
  runCommand: String
  build: Boolean
}

union Runtime = CloudRuntime | KubernetesRuntime

enum SavingsPlanPaymentOption {
  NO_UPFRONT
  PARTIAL_UPFRONT
  ALL_UPFRONT
  LIGHT_UTILIZATION
  MEDIUM_UTILIZATION
  HEAVY_UTILIZATION
}

type SavingsPlanRecommendation {
  currentOnDemandSpend: String
  estimatedSavingsAmount: String
  estimatedSavingsPercentage: String
  estimatedOnDemandCostWithCurrentCommitment: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
  details: [SavingsPlanRecommendationDetail!]
}

type SavingsPlanRecommendationDetail {
  instanceFamily: String
  offeringId: String
  region: String
  currentAverageHourlyOnDemandSpend: String
  estimatedAverageUtilization: String
  upfrontCost: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
}

input SavingsPlanRecommendationsInput {
  paymentOption: SavingsPlanPaymentOption!
  type: SavingsPlanType!
  term: SavingsPlanTerm!
}

enum SavingsPlanTerm {
  ONE_YEAR
  THREE_YEARS
}

enum SavingsPlanType {
  COMPUTE_SP
  EC2_INSTANCE_SP
  SAGEMAKER_SP
}

input SearchHelmChartsInput {
  first: Int
  after: String
  query: String
}

type ServerlessConfig {
  service: String
  provider: ServerlessProvider
  functions: [ServerlessFunction!]
  awsStackName: String
}

type ServerlessFunction {
  name: String!
  handler: String
}

type ServerlessProvider {
  name: String
  runtime: String
  stage: String
  region: String
  stackName: String
}

type ServerlessResourceSpec {
  cpu: Float
  memory: Float
}

input ServerlessResourcesSpecInput {
  cpu: Float
  memory: Float!
}

input SetRepoEnvsInput {
  id: ID!
  envs: [EnvVarInput!]!
}

input SignInWithWeb3Input {
  challengeId: UUID!
  signature: String!
}

type SlackIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type SlackWebhookIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
}

type StripePrice {
  id: ID!
  product: StripeProduct!
  unitAmount: Int!
}

type StripeProduct {
  id: ID!
  name: String!
  description: String!
}

type StripeSubscription {
  id: ID!
  status: StripeSubscriptionStatus!
  items: [StripeSubscriptionItem!]!
  createdAt: Time!
}

type StripeSubscriptionItem {
  id: ID!
  price: StripePrice!
  quantity: Int!
}

enum StripeSubscriptionStatus {
  active
  past_due
  unpaid
  canceled
  incomplete
  incomplete_expired
  trialing
}

type StripeUser {
  id: ID!
  balance: Int!
}

type Subscription {
  repoUpdated(id: UUID!): Repo!
  deploymentUpdated(id: ID!): Deployment!
  deploymentBuildLogsAdded(input: BuildLogsInput!): LogEntry!
}

input SuggestProjectNameInput {
  name: String
  type: String
}

input SuggestTemplateNameInput {
  id: ID!
  name: String
}

type SyslogIntegration {
  host: String!
  port: String!
  mode: String!
}

input SyslogIntegrationInput {
  host: String!
  port: String!
  mode: String!
}

type TCPProbe {
  host: String
  port: String!
}

type Team implements ProfileOwner & ProjectOwner {
  id: UUID!
  login: String!
  name: String!
  avatar: URL
  user: User!
  awsAccounts: [AWSAccount!]
  parent: Team
  children: [Team!]
  members: [UserTeamEdge!]!
  memberInvitations: [TeamMemberInvitation!]!
  projects(input: ProjectsInput): ProjectConnection!
  plan: Plan!
}

type TeamMemberInvitation {
  id: UUID!
  team: Team!
  role: TeamMemberRole!
  link: String!
  email: String
  expiresAt: Time
  createdAt: Time!
}

enum TeamMemberRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

type Template {
  id: ID!
  name: String!
  description: String!
  image: String!
  homepageURL: String
  repositoryURL: String
  stats: TemplateStats
  projects: [ProjectTemplate!]!
}

type TemplateStats {
  deploys: Int!
  forks: Int!
  stars: Int!
}

type TerraformModule {
  id: ID!
  owner: String
  namespace: String
  name: String
  version: String
  provider: String
  description: String
  source: String
  publishedAt: Time
  downloads: Int
  verified: Boolean
  registry: TerraformRegistry!
}

type TerraformModuleConnection {
  totalCount: Int!
  nodes: [TerraformModule!]!
  pageInfo: PageInfo!
}

type TerraformOperation {
  id: UUID!
  state: TerraformOperationState!
  approved: Boolean!
  config: JSON
  planStage: PipelineStage
  applyStage: PipelineStage
}

enum TerraformOperationState {
  PENDING
  PLANNING
  WAITING_FOR_APPROVAL
  APPLYING
  PLAN_FAILED
  APPLY_FAILED
  CANCELED
  SUCCEEDED
}

type TerraformRegistry {
  id: ID!
  url: URL
  module(id: ID!): TerraformModule!
}

scalar Time

enum TimeFilter {
  Monthly
  Daily
}

type TimePeriod {
  startAt: Time!
  endAt: Time!
}

input TPUInput {
  type: String!
  cores: Int!
  tfVersion: String!
}

type TPUSpec {
  tfVersion: String!
  type: String!
  cores: Int!
}

input TransferProjectInput {
  id: ID!
  to: ID!
}

input UpdateBranchInput {
  id: UUID
  repoID: UUID
  name: String
  image: String
  githubSha: String
  build: Boolean
  deploy: Boolean
}

input UpdateCDNInput {
  id: UUID!
  domains: [String!]
}

input UpdateClusterDomainInput {
  domain: String!
  clusterID: UUID!
}

input UpdateClusterInput {
  id: UUID!
  kubeconfig: Upload
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
}

input updateDatabaseLinkInput {
  id: UUID!
  envPrefix: String
}

input UpdateIPFSServiceInput {
  id: UUID!
  accessToken: String
}

input UpdateProjectDangerInput {
  id: UUID!
  namespace: String
  appID: String
  deployTarget: ProjectDeployInput
}

input UpdateProjectEnvironmentInput {
  id: UUID!
  name: String
  envs: [EnvVarInput!]
}

input UpdateProjectInput {
  id: ID!
  path: String
  name: String
  dockerImage: String
  githubIntegration: GitHubRepoIntegrationInput
  buildType: String
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  releaseCommand: String
  nodejsVersion: String
  noBuildCache: Boolean
  kanikoFlags: KanikoFlagsInput
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  serverlessResources: ServerlessResourcesSpecInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  hostNetwork: Boolean
  staticIP: Boolean
  iamPolicies: [String!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployStrategy: DeployStrategy
  helmVersion: String
  helmValues: String
  terraformVersion: String
  terraformVariables: String
  awsIamRole: String
  gcpServiceAccount: String
  clusterIssuerName: String
  logShipper: LogShipperInput
  deployService: Boolean
  cronJobSchedule: String
  productionBranch: String
  containerRegistry: UUID
  nodeSelector: JSON
  secretMounts: [KubernetesSecretMountInput!]
  kubernetesCustomization: KubernetesCustomizationInput
  buildCPU: Float
  buildMemory: Float
  cpu: String
  memory: String
  ephemeralStorage: Float
  gpu: GPUInput
  tpu: TPUInput
  dedicated: Boolean
  githubInstallationID: String
  githubRepository: String
  deployBranch: Boolean
  branchIgnore: String
  datadogApmEnabled: Boolean
  deployTarget: ProjectDeployInput
}

input UpdateProjectV2Input {
  id: UUID!
  name: String
  envs: [EnvVarInput!]
}

input UpdateRepoCustomDomainInput {
  id: UUID!
  disableCertManager: Boolean
}

input UpdateTeamInput {
  id: UUID!
  plan: UpdateTeamPlanInput
  paymentMethod: String
}

input UpdateTeamMemberRoleInput {
  id: UUID!
  role: TeamMemberRole!
}

input UpdateTeamPlanInput {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod!
}

input UpdateUserInput {
  id: UUID!
  avatar: URL
  login: String
  name: String
  email: String
}

input UpdateWebhookIntegrationInput {
  userID: UUID!
  id: UUID!
  url: String!
}

scalar Upload

scalar URL

type User implements ProfileOwner & ProjectOwner {
  id: ID!
  login: String!
  name: String!
  avatar: URL
  isTeam: Boolean
  canDeploy: Boolean
  hasZeetCloud: Boolean
  hasOnboarded: Boolean
  advanced: Boolean
  email: String
  billingEmail: String
  createdAt: Time
  hasPaymentMethod: Boolean
  needsPaymentMethod: Boolean
  billingURL: String
  stripe: StripeUser
  freeQuota: Int
  freeTrialEndsAt: Time
  freeLimitExceeded: Boolean
  paymentError: String
  paymentAuthorizationError: String
  teams: [UserTeamEdge!]
  team(id: ID!): Team
  repos(first: Int = 10, after: String, input: ReposInput): [Repo!]
  repo(id: ID!): Repo
  projects(input: ProjectsInput): ProjectConnection!
  deployment(id: ID!): Deployment
  githubInstallations: [GitHubInstallation!]
  githubRepositories(installationID: ID!): [GitHubRepository!]
  githubRepository(installationID: ID!, owner: String!, repo: String!): GitHubRepository
  dockerRepository(image: String!): DockerRepository
  suggestProjectName(input: SuggestProjectNameInput!): String!
  checkProjectName(input: CheckProjectNameInput!): Boolean!
  suggestTemplateName(input: SuggestTemplateNameInput!): String!
  awsAccount(id: UUID!): AWSAccount
  awsAccounts: [AWSAccount!]
  gcpAccounts: [GCPAccount!]
  doAccounts: [DOAccount!]
  linodeAccounts: [LinodeAccount!]
  coreweaveAccounts: [CoreWeaveAccount!]
  cloudAccount(id: ID!): CloudAccount
  jobRun(id: UUID!): JobRun!
  cluster(id: UUID!): Cluster
  clusters: [Cluster!]
  defaultCluster: Cluster
  apiKeys: [APIKey!]
  containerRegistries: [ContainerRegistry!]
  integrations: [Integration!]
  ipfsServices: [IPFSService!]
}

enum UserAction {
  READ_PRIVATE
  EDIT_BILLING
}

type UserAuth {
  authToken: String!
}

type UserIamConnection {
  userId: String!
  awsIamArn: String!
  awsAccountId: String!
  id: UUID!
}

type UserTeamEdge {
  id: UUID!
  user: User!
  team: Team!
  role: TeamMemberRole!
}

scalar UUID

type Volume {
  id: ID!
  spec: VolumeSpec!
}

input VolumeInput {
  mountPath: String!
  size: Int!
}

type VolumeSpec {
  size: Int!
  mountPath: String!
}

type Web3Challenge {
  id: UUID!
  address: String!
  nonce: String!
}

scalar YAML

