directive @enforceUserAction(action: UserAction!) on FIELD_DEFINITION

directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

"""
The @specifiedBy built-in directive is used within the type system definition
language to provide a scalar specification URL for specifying the behavior of
custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR

type AcceleratorSpec {
  type: String
  count: Int
  tpuTfVersion: String
}

input AcceleratorSpecInput {
  type: String!
  count: Int!
  tpuTfVersion: String
}

input AdapterStatusCriterion {
  value: [String]
}

input AddAWSAccountInput {
  userID: UUID!
  accountID: String!
}

input AddAzureAccountInput {
  userID: UUID!
  name: String
  subscriptionID: String!
  tenantID: String!
  clientID: String!
  clientSecret: String!
}

input AddCDNInput {
  id: UUID!
  provider: CDNProvider!
  domains: [String!]
}

input AddClusterInput {
  userID: UUID!
  kubeconfig: Upload
  awsAccountID: UUID
  gcpAccountID: UUID
  name: String
  region: String
}

input AddContainerRegistryInput {
  userID: UUID!
  name: String!
  registry: String!
  username: String!
  password: String!
}

input AddCoreWeaveAccountInput {
  userID: UUID!
  kubeconfig: Upload
}

input AddDOAccountInput {
  userID: UUID!
  accessToken: String!
}

input AddGCPAccountInput {
  userID: UUID!
  projectID: String!
  credentials: Upload!
}

input AddLinodeAccountInput {
  userID: UUID!
  accessToken: String!
}

input AddProjectCollaboratorInput {
  id: ID!
  user: String!
  role: ProjectCollaboratorRole!
}

input AddRepoCustomDomainInput {
  id: UUID!
  domain: String!
  certManagerChallengerType: CertManagerChallengeType
  syncDomainID: UUID
}

input AddTeamMemberInput {
  id: UUID!
  username: String
  userID: UUID
  role: TeamMemberRole!
}

input AddVultrAccountInput {
  userID: UUID!
  name: String!
  accessToken: String!
}

type AlternativeImage {
  reference: String
  tag: String
  name: String
}

type APIKey {
  id: UUID!
  token: String!
  name: String!
  description: String!
  createdAt: Time!
}

input AttachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

type AttachedAwsIamPolicy {
  arn: String!
  policyName: String!
  groupName: String!
}

type Autoscaling {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTrigger!]
  kedaScaledObjectSpec: String
}

input AutoscalingInput {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTriggerInput!]
  kedaScaledObjectSpec: String
}

type AutoscalingTrigger {
  type: AutoscalingType!
  spec: YAML!
}

input AutoscalingTriggerInput {
  type: AutoscalingType!
  spec: YAML!
}

enum AutoscalingType {
  CPU
  MEMORY
  PROMETHEUS
  CUSTOM
}

type AWSAccount {
  id: UUID!
  name: String!
  state: AWSAccountState!
  connected: Boolean
  accountID: String
  roleARN: String
  externalID: String
  cloudFormationURL: String!
  cloudFormationReadOnlyURL: String!
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  iamUsers: [AwsUser!]
  userIamConnections: [UserIamConnection!]
  awsIamPolicies: [AwsIamPolicy!]
  awsPolicyJson(input: awsPolicyJsonInput!): AwsPolicyJson
  cloudQuery: CloudQueryService
  costs(input: AwsCostsInput!): [AwsCostItem!]!
  costsByService(input: AwsCostsByServiceInput!): [GroupedAwsCostItem!]!
  savingsPlanRecommendations(input: SavingsPlanRecommendationsInput!): SavingsPlanRecommendation
  rightSizingRecommendations: [RightSizingRecommendation!]
  awsResources(input: AwsResourceSearchInput): AwsResourcesOutput!
  networks: [Network!]
}

enum AWSAccountState {
  WAITING
  SUCCESS
  ERROR
}

type AwsCostItem {
  timePeriod: TimePeriod!
  total: AwsCostTotal!
}

input AwsCostsByServiceInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
  services: [String!]!
}

input AwsCostsInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
}

type AwsCostTotal {
  amount: String!
  unit: String!
}

type AwsIamPolicy {
  arn: String!
  policyName: String!
  awsAccountId: String!
}

type AWSLambda {
  id: UUID!
  name: String!
  region: String
  awsAccount: AWSAccount
  arn: String
  apiGatewayUrl: String
}

type AWSLinks {
  cloudformation: String
  lambda: String
  apiGateway: String
  cloudwatchMetrics: String
  cloudwatchLogs: String
  eks: String
  rds: String
  ec2: String
  vpc: String
  iam: String
}

type AwsPolicyJson {
  awsPolicyJson: JSON!
}

input awsPolicyJsonInput {
  arn: String
  username: String
  policyName: String
}

type AwsRegionStatus {
  enabled: Boolean!
  region: String!
  regionName: String
  message: String
}

type AwsResource {
  arn: String!
  type: String!
  region: String
}

input AwsResourceSearchInput {
  region: String
  tag: String
  nextToken: String
}

type AwsResourcesOutput {
  awsResources: [AwsResource!]
  nextToken: String
}

type AwsServiceCostItem {
  service: String!
  total: AwsCostTotal!
}

type AwsUser {
  arn: String!
  userId: String!
  username: String!
  awsAccountId: String!
  attachedAwsPolicies: [AttachedAwsIamPolicy]!
}

type AzureAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  connected: Boolean
  subscriptionID: String
  tenantID: String
  clientID: String
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
}

type Blueprint {
  id: UUID!
  slug: String!
  displayName: String!
  published: Boolean!
  type: BlueprintType!
  isOfficial: Boolean
  description: String
  tags: [String!]!
  logoUrl: String
  configuration: BlueprintConfiguration
  variables: [BlueprintVariableSpec!]!
  projectCount: Int!
  richInputSchema: JSON
  owner: BlueprintOwner
}

union BlueprintConfiguration = BlueprintTerraformConfiguration | BlueprintManifestConfiguration | BlueprintHelmConfiguration

input BlueprintConfigurationInput {
  terraform: BlueprintTerraformConfigurationInput
  manifest: BlueprintManifestConfigurationInput
  helm: BlueprintHelmConfigurationInput
}

input BlueprintConfigurationUpdate {
  terraform: BlueprintTerraformConfigurationUpdate
}

type BlueprintConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  nodes: [Blueprint!]!
}

enum BlueprintDriver {
  TERRAFORM
  KUBERNETES_MANIFEST
  HELM
}

enum BlueprintDriverAction {
  PLAN_DESTROY
  PLAN
  APPROVE
  APPLY
}

type BlueprintDriverActionExecution {
  id: UUID!
  driver: BlueprintDriver!
  action: BlueprintDriverAction!
  createdAt: Time!
  updatedAt: Time!
  planExecution: BlueprintDriverActionExecution
  jobRun: JobRun
}

type BlueprintDriverActionExecutionConnection {
  pageInfo: PageInfo!
  nodes: [BlueprintDriverActionExecution!]!
}

input BlueprintDriverActionInput {
  projectID: UUID!
  driver: BlueprintDriver!
  action: BlueprintDriverAction!

  """
  Action-dependent input for the action execution
  
  Because GraphQL does not support Input Unions, this field cannot be statically type-checked.
  To document the structure for this field, we publish the input types in this schema.
  For example, if you are issuing the APPLY action to the TERRAFORM driver, look for TerraformPlanActionParameters.
  """
  parameters: Object
}

type BlueprintDriverActionResult {
  execution: BlueprintDriverActionExecution
}

type BlueprintHelmConfiguration {
  source: Source
}

input BlueprintHelmConfigurationInput {
  releaseName: String!
  source: SourceInput
}

input BlueprintHelmConfigurationUpdate {
  source: SourceInput
}

type BlueprintManifestConfiguration {
  source: Source
  useKustomize: Boolean
}

input BlueprintManifestConfigurationInput {
  source: SourceInput
  useKustomize: Boolean
}

input BlueprintManifestConfigurationUpdate {
  source: SourceInput
  useKustomize: Boolean
}

type BlueprintOwner implements ProfileOwner {
  login: Login!
  name: String!
  avatar: URL
}

type BlueprintsMarketplace {
  blueprints(page: PageInput): BlueprintConnection
  blueprint(owner: Login!, slug: String!): Blueprint
}

type BlueprintTerraformConfiguration {
  registrySource: String
  moduleVersionConstraint: String
  githubSource: String
}

input BlueprintTerraformConfigurationInput {
  registrySource: String
  moduleVersionConstraint: String
  githubSource: String
  gitIntegration: GitSourceIntegrationInput
}

input BlueprintTerraformConfigurationUpdate {
  gitIntegration: GitSourceIntegrationInput
}

enum BlueprintType {
  TERRAFORM
  KUBERNETES_MANIFEST
  HELM
  ZEET_KUBERNETES
  ZEET_AWS_LAMBDA
  ZEET_GCP_CLOUD_RUN
}

union BlueprintVariable = BlueprintVariableString | BlueprintVariableBoolean | BlueprintVariableInt | BlueprintVariableFloat | BlueprintVariableJSON

type BlueprintVariableBoolean {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Boolean!
}

type BlueprintVariableFloat {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Float!
}

"""
A ProjectV3's BlueprintVariable represent key-value pairs: each a variable name and its value.
These variables can either reference a variable spec, as defined by the Blueprint, or they can be declared
as "custom variables" for the ProjectV3.

To reference a variable spec, specify either variableSpecID or the variableName that corresponds to a variable spec.

To declare a custom variable, specify the variableName and the variableType.
If there is a variableSpec with the same name, the variableType will be ignored, and the variableSpec will take precedence.

All BlueprintVariables must specify their value. The VariableValueInput is serialized as a string, and is parsed
server-side according to the variableType.
"""
input BlueprintVariableInput {
  """
  ID of the corresponding variable spec. Must be present if variableName is not specified.
  """
  variableSpecID: UUID

  """
  Name of the corresponding variable spec, or name to use when declaring a variable without referencing a variable spec.
  Must be present if variableSpecID is not specified.
  """
  variableName: String

  """
  The variable value. Always a string value, which will be parsed according to the variableType, determined either
  by the referenced variableSpec, or the provided variableType
  """
  value: VariableValueInput!

  """
  Type specification is required when variable is being declared without referencing a variable spec.
  """
  variableType: BlueprintVariableType
}

type BlueprintVariableInt {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Int!
}

type BlueprintVariableJSON {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: JSON!
}

type BlueprintVariableSpec {
  id: UUID!
  name: String!
  type: BlueprintVariableType!
  required: Boolean!
}

input BlueprintVariableSpecInput {
  name: String!
  type: BlueprintVariableType!
  required: Boolean!
}

type BlueprintVariableString {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: String!
}

enum BlueprintVariableType {
  STRING
  BOOLEAN
  INTEGER
  FLOAT
  JSON
}

input BranchInput {
  active: Boolean
}

type Build {
  id: UUID!
  state: BuildState!
  image: String
  version: String
  errorMessage: String
  logs: Logs
  metrics(name: String!): [Metric!]
  backend: String
  buildID: String
  createdAt: Time!
  updatedAt: Time!
}

input BuildLogsInput {
  deploymentID: ID!
  after: String
}

type BuildMethod {
  name: String!
  type: BuildType!
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  staticPath: String
  runCommand: String
  releaseCommand: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
}

type BuildStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
  build: Build
  buildTemplates: [BuildTemplate!]
}

enum BuildState {
  BUILD_STARTING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
}

enum BuildTarget {
  NULL_REGISTRY
  CLUSTER_REGISTRY
  CONTAINER_REGISTRY
}

input BuildTargetInput {
  buildTarget: BuildTarget!
  clusterID: UUID
}

type BuildTemplate {
  type: BuildTemplateType!
  output: String
}

enum BuildTemplateType {
  DOCKERFILE
}

enum BuildType {
  DOCKER
  BUILDPACKS
  PYTHON
  PYTHON_DJANGO
  NODE
  NODE_STATIC
  NODE_NEXTJS
  UBUNTU
  ELIXIR_PHOENIX
  GOLANG_MODULES
  HEROKUISH
}

type CDN {
  id: UUID!
  provider: CDNProvider!
  domains: [CDNDomain!]
  state: String!
  origin: String
  endpoint: String
  certificate: Certificate
}

type CDNDomain {
  domain: String!
  certReady: Boolean
  routeReady: Boolean
  instruction: DNSRecord
}

enum CDNProvider {
  AWS_CLOUDFRONT
}

type Certificate {
  provider: CertificateProivder
  dnsNames: [String!]
  issuing: Boolean!
  ready: Boolean!
  challenges: [CertificateChallenge!]
  instructions: [DNSRecord!]
  createdAt: Time!
  updatedAt: Time!
}

type CertificateChallenge {
  dnsName: String!
  type: String!
  solver: String!
  wildcard: Boolean!
  statusReason: String!
  statusState: String!
}

enum CertificateProivder {
  CERT_MANAGER
  AWS_ACM
}

enum CertManagerChallengeType {
  dns01
  http01
}

input CheckPriceInput {
  teamId: UUID
  source: RepoSourceType
  installation: ID
  owner: String
  repo: String
  dockerImage: String
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  cpu: String
  gpu: String
  memory: String
  dedicated: Boolean
}

type CheckPriceOutput {
  total: PriceComponent!
  subTotal: PriceComponent!
  cpu: PriceComponent!
  memory: PriceComponent!
  gpu: PriceComponent!
  volumes: PriceComponent!
  bandwidth: PriceComponent!
  misc: PriceComponent!
  canBeFreeTier: Boolean!
}

input CheckProjectNameInput {
  name: String!
}

interface CISource {
  name: String!
  owner: String!
  url: URL!
  description: String
}

union CloudAccount = AWSAccount | GCPAccount | DOAccount | LinodeAccount | VultrAccount

enum CloudAccountState {
  WAITING
  SUCCESS
  ERROR
}

enum CloudProvider {
  UNKNOWN
  ZEET
  AWS
  AZURE
  GCP
  ALIBABA
  OCI
  IBM
  TENCENT
  DO
  COREWEAVE
  OVH
  LINODE
  VULTR
  SCALEWAY
}

type CloudQueryService {
  state: CloudQueryState!
  id: UUID!
}

enum CloudQueryState {
  READY
  ERROR
  CREATING
  DELETING
}

type CloudResource {
  resourceType: CloudResourceType!
  id: String!
  shared: Boolean!
  region: String!
}

enum CloudResourceType {
  Machine
  Disk
  LoadBalancer
  VPC
  Cluster
}

type CloudRuntime {
  cloud: CloudAccount
  region: String
  awsLambda: String
  awsFargate: String
  gcpCloudRun: String
  azureApp: String
}

type Cluster {
  id: UUID!
  name: String!
  region: String
  state: ClusterState!
  private: Boolean!
  connected: Boolean
  cloudProvider: CloudProvider
  clusterProvider: ClusterProvider
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  doAccount: DOAccount
  cwAccount: CoreWeaveAccount
  linodeAccount: LinodeAccount
  cloudAccount: CloudAccount
  vultrAccount: VultrAccount
  namespace: String
  domain: String
  isExternal: Boolean
  ingressIP: String
  ingressDNS: String
  clusterIssuers: [String!]
  prometheus: Prometheus
  grafana: Grafana
  staticIPs: [String!]
  kubeconfig: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistry: ContainerRegistry
  projects(input: ProjectsInput): ProjectConnection
  customDomains: [ClusterCustomDomain!]

  """All configured cluster add-ons, whether currently enabled or disabled"""
  addOns: [ClusterAddOn!]
  createdAt: Time!
  updatedAt: Time!
  network: Network
  machines: [Machine!]
}

type ClusterAddOn {
  slug: String!
  state: ClusterAddOnState!
  helmValues: YAML
}

enum ClusterAddOnState {
  ENABLED
  DISABLED
}

type ClusterCustomDomain {
  id: UUID!
  cluster: Cluster
  repo: Repo
  customDomain: CustomDomain
}

type ClusterDomains {
  id: ID!
  cluster: Cluster!
  domains: [CustomDomain!]
}

enum ClusterProvider {
  GENERIC
  EKS
  GKE
  DOKS
  COREWEAVE
  LKE
}

enum ClusterState {
  PENDING
  CREATING
  HEALTHY
  DELETING
  ERROR
  ERROR_DELETING
}

input ConnectUserToIamInput {
  userID: UUID!
  awsIamArn: String
  awsAccountId: String
}

type Container {
  id: UUID!
  status: ContainerStatus!
}

type ContainerRegistry {
  id: UUID!
  name: String!
  registry: String!
  username: String
  credentialProvider: ContainerRegistryCredentialProvider
}

enum ContainerRegistryCredentialProvider {
  DOCKER
  ECR
  GCR
  DOCR
}

type ContainerRegistrySource {
  registryID: UUID
  registryURL: URL
  repository: String!
  tag: String
}

input ContainerRegistrySourceInput {
  registryID: UUID
  registryURL: URL
  repository: String!
  tag: String
}

type ContainerResourcesSpec {
  cpu: Float
  memory: Float
  ephemeralStorage: Float
  accelerator: AcceleratorSpec
  spot: Boolean
}

input ContainerResourcesSpecInput {
  cpu: Float!
  memory: Float!
  ephemeralStorage: Float
  accelerator: AcceleratorSpecInput
  spot: Boolean
}

type ContainerSpec {
  cpu: Float
  memory: Float
  gpu: Float
}

type ContainerStatus {
  scheduled: Boolean!
  running: Boolean!
  ready: Boolean!
}

type CoreWeaveAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  namespace: String
  connected: Boolean
  clusters: [Cluster!]
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type Cost {
  service: String
  unblendedCostAmount: Float
  unblendedCostUnit: String
  periodStart: String
  periodEnd: String
}

input CostByServiceWhere {
  services: [String!]!
}

input CostUsageWhere {
  granularity: String!
  dimensionType1: String!
  dimensionType2: String!
  dimension2NotIn: [String!]!
  dimension1In: [String!]!
}

input CreateAPIKeyInput {
  userID: UUID!
  name: String!
}

input CreateBlueprintInput {
  userID: UUID!
  slug: String!
  displayName: String!
  published: Boolean!
  type: BlueprintType!
  configuration: BlueprintConfigurationInput
  variables: [BlueprintVariableSpecInput!]!
  richInputSchema: JSON
}

input CreateClusterInput {
  userID: UUID!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  name: String!
  region: String!
}

input CreateDatabaseInput {
  userID: UUID!
  name: String!
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: DatabaseDeployTargetInput!
  engine: DatabaseEngineType!
  version: String!
  options: DatabaseOptions
}

input CreateDatadogIntegrationInput {
  userID: UUID!
  apiKey: String!
}

input CreateEventIntegrationInput {
  userID: UUID!
  eventType: EventIntegrationType!
  clusterID: UUID
}

input CreateGitlabIntegrationInput {
  userID: UUID!
  name: String
  apiUrl: URL
  accessToken: String!
}

input CreateIPFSServiceInput {
  userID: UUID!
  name: String!
  awsAccountID: UUID!
  clusterID: UUID!
}

input CreateManifestAppInput {
  userID: UUID!
  projectID: UUID
  environmentName: String
  environmentID: UUID
  name: String!
  deployTarget: ProjectDeployInput!
  namespace: String
  githubConnection: GithubConnectionInput
  gitRepository: String
  manifests: [String!]
  manifestValue: String
}

input CreateProjectDockerInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: ProjectDeployInput
  dockerImage: String!
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  ephemeralStorage: Float
  dedicated: Boolean
  gpu: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectEnvironmentInput {
  projectID: UUID!
  name: String!
  repos: [UUID!]
}

input CreateProjectFromProjectTemplateInput {
  id: ID!
  deployTarget: ProjectDeployInput
  envs: [EnvVarInput!]
}

input CreateProjectGitInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  url: String!
  productionBranch: String
  buildTarget: BuildTargetInput
  deployTarget: ProjectDeployInput
  build: ProjectBuildInput
  deployService: Boolean
  deployJob: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: [PortInput!]
  volumes: [VolumeInput!]
  replication: [ReplicationInput!]
  runCommand: String
  logShipper: LogShipperInput
  deployStrategy: DeployStrategy
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  clusterIssuerName: String
  hostNetwork: Boolean
  staticIP: Boolean
  nodeSelector: JSON
  noBuildCache: Boolean
  kanikoFlags: KanikoFlagsInput
  datadogApmEnabled: Boolean
  enabled: Boolean
  pipelineClusterID: UUID
  path: String
}

input CreateProjectHelmInput {
  userID: UUID!
  projectID: UUID
  environmentName: String
  environmentID: UUID
  name: String!
  deployTarget: ProjectDeployInput!
  namespace: String
  releaseName: String!
  repository: String
  chart: String
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  values: String
  valuesRef: String
  enabled: Boolean
}

input CreateProjectInput {
  userID: UUID
  name: String
  projectID: UUID
  environmentID: UUID
  projectName: String
  environmentName: String
  installation: ID
  owner: String
  repo: String
  gitRepository: String
  githubConnection: GithubConnectionInput
  gitlabConnection: GitlabConnectionInput
  buildTarget: BuildTargetInput
  deployTarget: ProjectDeployInput
  productionBranch: String
  deployService: Boolean
  deployJob: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  dedicated: Boolean
  gpu: String
  buildCommand: String
  buildType: String
  runCommand: String
  staticPath: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectsFromTemplateInput {
  id: ID!
  userID: UUID
  name: String
  projects: [CreateProjectFromProjectTemplateInput!]
}

input CreateProjectTerraformInput {
  userID: UUID!
  name: String!
  deployTarget: ProjectDeployInput!
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  variables: JSON
  envs: [EnvVarInput!]
  terraformVersion: String
  manualApproval: Boolean
  enabled: Boolean
}

input CreateProjectV2Input {
  userID: UUID!
  name: String!
}

input CreateProjectV3Input {
  blueprintID: UUID!
  userID: UUID!
  name: String!
  requirePlanApproval: Boolean
  blueprintConfiguration: BlueprintConfigurationInput
  variables: [BlueprintVariableInput!]!
  terraformConfiguration: TerraformProjectV3ConfigurationInput
  manifestConfiguration: ManifestProjectV3ConfigurationInput
  helmConfiguration: HelmProjectV3ConfigurationInput
  projectID: UUID
  projectName: String
  environmentID: UUID
  environmentName: String
}

input CreateRepoPipelineLinkInput {
  sourceRepoID: UUID!
  sourceEvent: RepoEvent!
  targetRepoID: UUID
  targetEnvironmentID: UUID
  targetAction: RepoAction!
}

input CreateResourceAlphaInput {
  userID: UUID!
  projectID: UUID
  projectName: String
  environmentID: UUID
  environmentName: String
  name: String!
  appID: String
  enabled: Boolean
  workflow: ResourceWorkflowInput
  branch: ResourceBranchInput
  source: SourceInput
  build: ResourceBuildInput
  kubernetes: ResourceKubernetesInput
  serverless: ResourceServerlessInput
  terraform: ResourceTerraformInput
  database: ResourceDatabaseInput
  blueprintID: UUID
}

input CreateTeamInput {
  name: String!
  login: String
  billingEmail: String!
  avatar: String
  paymentMethod: String
  tier: PlanTier
  billingPeriod: PlanBillingPeriod
}

input CreateWeb3ChallengeInput {
  address: String!
}

input CreateWebhookIntegrationInput {
  userID: UUID!
  url: String!
}

type CustomDomain {
  id: ID!
  domain: String!
  cnameTargets: [String!]
  ipTargets: [String!]
  isApex: Boolean!
  disableCertManager: Boolean
  certManagerChallengeType: CertManagerChallengeType
  syncDomain: CustomDomain
  instructions: [DNSRecord!]
  certificate: Certificate
}

input DatabaseDeployTargetInput {
  provider: DatabaseProviderType!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  clusterID: UUID
  region: String
}

enum DatabaseEngineType {
  POSTGRES
  MYSQL
  MONGODB
  REDIS
  KAFKA
  NATS
}

type DatabaseLink {
  id: UUID!
  repo: Repo!
  database: Repo!
  envPrefix: String
  envs: [EnvVar!]
}

input DatabaseOptions {
  username: String
  password: String
  database: String
}

enum DatabaseProviderType {
  AWS_RDS
  GCP_CLOUD_SQL
  DO_DATABASE
  DOCKER
}

type DatadogIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiKey: String
}

type DatadogLogIntegration {
  key: String!
  host: String
}

input DatadogLogIntegrationInput {
  key: String!
  host: String
}

input DeployableDriverActionExecutionFilter {
  ids: MultiEntityCriterion
  actionTypes: DriverActionTypeCriterion
  resourceIds: MultiEntityCriterion
}

type Deployment {
  id: ID!
  description: String
  version: String!
  status: DeploymentStatus!
  endpoints: [String!]
  privateEndpoint: String
  loadBalancers: [LoadBalancer!]
  errorMessage: String
  branch: String
  build: Build
  buildStage: BuildStage
  testStage: PipelineStage
  releaseStage: PipelineStage
  deployStage: PipelineStage
  deleteStage: PipelineStage
  deployTemplates: [DeployTemplate]
  logs: [LogEntry!]
  repo: Repo
  deployStatus: DeployStatus
  containers: [Container!]
  metrics(name: String!): [Metric!]
  volumes: [Volume!]
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  githubLinks: GithubLinks
  helmRelease: HelmRelease
  dataOut: String
  pipelineCluster: Cluster
  createdAt: Time!
  updatedAt: Time!
  release: Release
  deployStep: PipelineStep
  alternativeImages: [AlternativeImage!]
  events: [Event!]!
  runtime: Runtime
  terraformOperation: TerraformOperation
}

type DeploymentConnection {
  totalCount: Int!
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

input DeploymentsInput {
  first: Int = 10
  after: String
  branch: String
}

enum DeploymentStatus {
  BUILD_PENDING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
  DEPLOY_PENDING
  DEPLOY_IN_PROGRESS
  RELEASE_IN_PROGRESS
  DEPLOY_FAILED
  DEPLOY_SUCCEEDED
  BUILD_ABORTED
  DEPLOY_STOPPED
  DEPLOY_HEALHTY
  DEPLOY_CRASHING
}

input DeployRepoBranchInput {
  id: UUID!
  branch: String!
}

enum DeployRuntime {
  AWS_LAMBDA
  AWS_ECS
  GCP_CLOUD_RUN
  KUBERNETES
  KNATIVE
}

type DeployStatus {
  active: Boolean!
  publicIPs: [String!]
  state: String!
  replicas: Int!
  runningReplicas: Int!
  readyReplicas: Int!
  errorMessage: String
}

enum DeployStrategy {
  RESTART
  ROLLING
  CANARY
  BLUE_GREEN
  RED_BLACK
}

enum DeployTarget {
  KUBERNETES
  SERVERLESS
  TERRAFORM
  PULUMI
  AWS_SAM
  AWS_CDK
  AWS_CLOUDFORMATION
  GCP_CLOUD_RUN
}

type DeployTemplate {
  type: DeployTemplateType!
  output: String
}

enum DeployTemplateType {
  YAML
}

enum DeployType {
  KUBERNETES
  KNATIVE
  HELM
  KUBECTL
  KUBERNETES_UNSTRUCTURED
}

input DetachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

enum DisableReason {
  FREE_TRIAL_ENDED
  USER_ACTION
  PAYMENT_ERROR
  USER_BANNED
}

type DiscordIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type DiscordWebhookIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
}

input dispatchRepoGroupActionInput {
  groupID: UUID
  selector: LabelSelectorsInput
  action: RepoActionInput!
}

type DNSRecord {
  name: String
  domain: String!
  type: DNSRecordType!
  value: String
}

enum DNSRecordType {
  A
  CNAME
  TXT
}

type DOAccount {
  id: UUID!
  name: String!
  state: DOAccountState!
  accessTokenPrefix: String
  accessToken: String
  defaultProject: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum DOAccountState {
  WAITING
  SUCCESS
  ERROR
}

type DockerImage {
  id: ID!
  tag: String!
  digest: String!
  repository: DockerRepository!
}

type DockerRepository implements CISource {
  id: ID!
  name: String!
  owner: String!
  url: URL!
  isPrivate: Boolean!
  description: String
  images: [DockerImage!]
  image(tag: String!): DockerImage
  ports: [Port!]
  volumes: [VolumeSpec!]
}

input DriverActionTypeCriterion {
  value: [BlueprintDriverAction]
  operator: FilterCriterionOperatorType
}

input DuplicateProjectInput {
  id: UUID!
  enabled: Boolean!
  name: String!
  projectID: UUID
  environmentName: String
  environmentID: UUID
}

input DuplicateRepoInput {
  repoID: UUID!
  name: String!
  environmentID: UUID!
}

type EnvironmentOverview {
  deploymentStatus: DeploymentStatus
  count: Int
}

type EnvVar {
  id: ID!
  name: String!
  value: String!
  visible: Boolean!
  sealed: Boolean!
  source: EnvVarSource
  createdAt: Time!
  updatedAt: Time!
}

input EnvVarInput {
  name: String!
  value: String!
  sealed: Boolean
}

type EnvVarSource {
  type: EnvVarSourceType!
}

enum EnvVarSourceType {
  ZEET
  PROJECT
  ENVIRONMENT
  CLUSTER
  DATABASE
}

type EnvVarTemplate {
  name: String!
  description: String!
  value: String
  generator: String
  reference: String
  required: Boolean!
  locked: Boolean!
  hidden: Boolean!
  options: [String!]
}

enum ErrorCode {
  CardDeclined
  NoContainers
  NeedAuth
  NeedPaymentDetails
  NoActiveBuildMethodError
  NoDockerfilePresent
  NoPortsExposed
  InternalServerError
}

type Event {
  id: String!
  type: EventType!
  message: String!
  source: String!
  count: Int!
  lastSeenAt: Time!
}

type EventIntegration {
  id: UUID!
  eventType: EventIntegrationType!
  integrationKey: String!
  integrationUrl: URL!
  clusterID: UUID
}

enum EventIntegrationType {
  SNS
}

enum EventType {
  INFO
  WARNING
  ERROR
}

input FilterCriterion {
  userFilter: UserFilter
  resourceFilter: ResourceFilter
  repoFilter: RepoFilter
  deployableDriverActionExecutionFilter: DeployableDriverActionExecutionFilter
  resourceAdapterFilter: ResourceAdapterFilter
}

enum FilterCriterionOperatorType {
  EQUALS
  NOT_EQUALS
  INCLUDES
  EXCLUDES
  STARTS
  ENDS
  CONTAINS
}

input FilterExpression {
  operator: FilterExpressionOperator
  filters: [FilterNode!]
}

enum FilterExpressionOperator {
  AND
  OR
  NOT
}

input FilterInput {
  sort: SortInput
  page: PageInput
  filter: FilterNode!
}

input FilterNode {
  expression: FilterExpression
  criterion: FilterCriterion
}

type GCPAccount {
  id: UUID!
  name: String!
  state: GCPAccountState!
  error: String
  connected: Boolean
  projectID: String
  clientEmail: String
  credentials: String
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum GCPAccountState {
  WAITING
  SUCCESS
  ERROR
}

type GCPLinks {
  deploymentManager: String
  cloudFunctions: String
  cloudFunctionsTrigger: String
  cloudRun: String
  cloudMonitoring: String
  cloudLogging: String
  gke: String
}

input GCSBucketBackendInput {
  gcpAccountID: UUID!
  bucketName: String!
  location: String
}

type GitBranch {
  id: ID!
  name: String!
  commit: GitCommit!
}

type GitCommit {
  id: ID!
  oid: String!
  abbreviatedOid: String!
  message: String!
  createdAt: Time!
}

type GithubCommitResult {
  processing: Boolean!
}

input GithubConnectionInput {
  apiUrl: URL
  installation: String!
  owner: String!
  repo: String!
}

type GitHubInstallation {
  id: ID!
  appID: Int!
  account: GitHubUser!
  repositorySelection: String!
  repositories: [GitHubRepository!]
}

type GithubLinks {
  commitURL: String
}

type GitHubRepoIntegration implements GitRepoIntegration {
  id: UUID!
  githubConnectionID: Int
  githubRepository: GitHubRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

input GitHubRepoIntegrationInput {
  githubConnectionID: Int
  githubOwner: String
  githubName: String
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  autoStopPullRequest: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

type GitHubRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
  buildMethodSuggestions: [BuildMethod!]
  serverless: ServerlessConfig
  ports: [Port!]
  volumes: [VolumeSpec!]
}

type GitHubUser {
  id: ID!
  login: String!
  avatar: URL
  type: GithubUserType!
}

enum GithubUserType {
  User
  Organization
}

input GitlabConnectionInput {
  gitlabIntegrationID: UUID!
  projectPath: String
}

type GitlabIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiUrl: URL!
  accessTokenPrefix: String
  webhookUrl: URL!
  webhookToken: String!
}

type GitlabRepoIntegration implements GitRepoIntegration {
  id: UUID!
  gitlabIntegration: GitlabIntegration
  gitlabRepository: GitlabRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

input GitlabRepoIntegrationInput {
  gitlabConnection: GitlabConnectionInput
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  autoStopPullRequest: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

type GitlabRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

enum GitProvider {
  GITHUB
  GITLAB
  BITBUCKET
}

interface GitRepoIntegration {
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

interface GitRepository {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

type GitSource {
  repository: String!
  ref: String
  path: String
  integration: GitSourceIntegration
}

input GitSourceInput {
  repository: String!
  ref: String
  path: String
  integration: GitSourceIntegrationInput
}

type GitSourceIntegration {
  githubInstallationID: Int
  githubIntegrationID: UUID
  gitlabIntegrationID: UUID
}

input GitSourceIntegrationInput {
  githubInstallationID: Int
  githubIntegrationID: UUID
  gitlabIntegrationID: UUID
}

input GPUInput {
  type: String
  count: Int!
}

type GPUSpec {
  type: String
  count: Int!
}

type Grafana {
  url: String!
  user: String
  password: String
}

type GroupedAwsCostItem {
  timePeriod: TimePeriod!
  groups: [AwsServiceCostItem!]!
}

type HelmChart {
  id: String!
  repository: HelmRepository!
  name: String
  normalized_name: String
  description: String
  logoImage: String
  stars: Int
  version: String
  app_version: String
  deprecated: Boolean
}

type HelmChartConnection {
  totalCount: Int!
  nodes: [HelmChart!]!
  pageInfo: PageInfo!
}

type HelmProjectV3Configuration {
  clusterID: UUID!
  namespace: String
}

input HelmProjectV3ConfigurationInput {
  clusterID: UUID!
  namespace: String
}

type HelmRelease {
  id: String!
  chart: HelmChart!
  version: String!
}

type HelmRepository {
  id: String!
  url: String
  name: String
  organization_name: String
  chart(name: String!): HelmChart!
}

type HelmRepositorySource {
  repositoryURL: URL!
  chart: String!
  version: String
}

input HelmRepositorySourceInput {
  repositoryURL: URL!
  chart: String!
  version: String
}

type HTTPProbe {
  host: String
  port: String!
  path: String
}

interface Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

enum IntegrationType {
  SLACK
  SLACK_WEBHOOK
  DISCORD
  DISCORD_WEBHOOK
  DATADOG
  GITLAB
}

input InviteTeamMemberInput {
  id: UUID!
  role: TeamMemberRole!
  email: String
  expiresAt: Time
}

type IPFSService {
  id: UUID!
  owner: User!
  state: IPFSServiceState!
  cluster: Cluster
  accessToken: String
  apiURL: String
  nodeURL: String
  api: Project
}

enum IPFSServiceState {
  CREATING
  HEALTHY
  DELETING
  ERROR
}

interface IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type JobRun {
  id: UUID!
  state: JobRunState!
  command: String!
  exitCode: Int
  logs: Logs
  metrics(name: String!): [Metric!]
  errorMessage: String
  createdAt: Time
  build: Build
}

type JobRunConnection {
  totalCount: Int!
  nodes: [JobRun!]!
  pageInfo: PageInfo!
}

enum JobRunState {
  JOB_RUN_STARTING
  JOB_RUN_RUNNING
  JOB_RUN_FAILED
  JOB_RUN_SUCCEEDED
  JOB_RUN_PENDING_APPROVAL
}

scalar JSON

type KanikoFlags {
  compressedCaching: Boolean
}

input KanikoFlagsInput {
  compressedCaching: Boolean
}

type KubernetesCustomization {
  nodeSelector: MapString
  hostNetwork: Boolean
  podSpecPatch: YAML
  serviceAccountName: String
  podAnnotations: MapString
  serviceAnnotations: MapString
  ingressAnnotations: MapString
  clusterIssuerName: String
}

input KubernetesCustomizationInput {
  nodeSelector: JSON
  hostNetwork: Boolean
  podSpecPatch: YAML
  podAnnotations: JSON
  serviceAnnotations: JSON
  ingressAnnotations: JSON
  clusterIssuerName: String
}

type KubernetesRuntime {
  cluster: Cluster
  region: String
}

type KubernetesSecretMount {
  secretName: String!
  mountPath: String!
  readOnly: Boolean!
}

input KubernetesSecretMountInput {
  secretName: String!
  mountPath: String!
}

enum LabelSelectorOperator {
  In
  NotIn
  Exists
  DoesNotExist
}

type LabelSelectorRequirement {
  key: String!
  operator: LabelSelectorOperator!
  values: [String!]
}

input LabelSelectorRequirementInput {
  key: String!
  operator: LabelSelectorOperator!
  values: [String!]
}

type LabelSelectors {
  matchLabels: MapString
  matchExpressions: [LabelSelectorRequirement!]
}

input LabelSelectorsInput {
  matchLabels: MapString
  matchExpressions: [LabelSelectorRequirementInput!]
}

input LinkCloudToClusterInput {
  cloudType: CloudProvider!
  cloudId: UUID!
  clusterID: UUID!
  cloudAZ: String
  cloudRegion: String
}

input LinkDatabaseInput {
  id: UUID!
  databaseID: UUID!
  envPrefix: String
}

type LinodeAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  accessTokenPrefix: String
  accessToken: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type LoadBalancer {
  name: String!
  dns: [String!]!
  ips: [String!]!
  ports: [Int!]
}

type LogDNAIntegration {
  key: String!
}

input LogDNAIntegrationInput {
  key: String!
}

type LogEntry {
  text: String!
  timestamp: Time
}

scalar Login

type Logs {
  id: ID!
  cursor: String
  completed: Boolean!
  entries: [LogEntry!]
}

type LogShipper {
  type: LogShipperType!
  logz: LogzIntegration
  syslog: SyslogIntegration
  logDNA: LogDNAIntegration
  datadog: DatadogLogIntegration
}

input LogShipperInput {
  type: LogShipperType
  logz: LogzIntegrationInput
  syslog: SyslogIntegrationInput
  logDNA: LogDNAIntegrationInput
  datadog: DatadogLogIntegrationInput
}

enum LogShipperType {
  LOGZIO
  SYSLOG
  LOGDNA
  DATADOG
}

type LogzIntegration {
  token: String!
  url: String
}

input LogzIntegrationInput {
  token: String!
  url: String!
}

type Machine {
  id: ID!
  name: String!
  region: String!
  data: JSON
  network: Network
  cluster: Cluster
  projects(input: ProjectsInput): ProjectConnection
}

type Manifest {
  manifests: [String!]
  manifestValue: String
  kustomizeDirs: [String!]
}

type ManifestProjectV3Configuration {
  clusterID: UUID!
  namespace: String
}

input ManifestProjectV3ConfigurationInput {
  clusterID: UUID!
  namespace: String
}

scalar Map

scalar MapString

type Metric {
  timestamp: Time!
  value: Float
}

input MoveRepoInput {
  id: UUID!
  projectID: UUID
  environmentName: String
  environmentID: UUID
  name: String
}

input MultiEntityCriterion {
  value: [UUID!]
}

type Mutation {
  enableRepo(id: ID!): Repo!
  disableRepo(id: ID!): Repo!
  deleteRepo(id: ID!): Boolean!
  buildRepo(id: ID!, branch: String, noCache: Boolean): Repo!
  abortBuild(id: UUID!): Repo!
  deployRepo(id: ID!): Repo!
  deployRepoBranch(input: DeployRepoBranchInput!): Repo!
  setRepoEnvs(input: SetRepoEnvsInput!): Repo!
  setPaymentMethod(paymentMethod: String!): User!
  copyEnvVars(from: ID!, to: ID!): Repo
  addProjectCollaborator(input: AddProjectCollaboratorInput!): Repo!
  removeProjectCollaborator(id: ID!): Repo!
  transferProject(input: TransferProjectInput!): Repo!
  createAPIKey(input: CreateAPIKeyInput): APIKey!
  deleteAPIKey(id: UUID!): Boolean!
  addAWSAccount(input: AddAWSAccountInput!): AWSAccount!
  verifyAWSAccount(id: UUID!): AWSAccount!
  removeAWSAccount(id: UUID!): Boolean!
  updateAWSAccount(input: UpdateAWSAccountInput!): Boolean!
  connectUserToIam(input: ConnectUserToIamInput!): Boolean!
  disconnectUserFromIam(id: UUID!): Boolean!
  attachAwsPolicyToUser(input: AttachAwsPolicyToUser!): Boolean!
  detachAwsPolicyToUser(input: DetachAwsPolicyToUser!): Boolean!
  checkAwsRegionConnection(awsAccountID: UUID!, region: String!): AwsRegionStatus!
  addAzureAccount(input: AddAzureAccountInput!): AzureAccount!
  updateAzureAccount(input: UpdateAzureAccountInput!): Boolean!
  removeAzureAccount(id: UUID!): Boolean!
  updateBranch(input: UpdateBranchInput!): RepoBranchV2!
  addCDN(input: AddCDNInput!): CDN!
  updateCDN(input: UpdateCDNInput!): CDN!
  removeCDN(id: UUID!): Boolean!
  invalidateCDNCache(id: UUID!): CDN!
  ensureCloudqueryEnabled(awsAccountId: UUID!): Boolean!
  createCluster(input: CreateClusterInput!): Cluster!
  deleteCluster(id: UUID!): Boolean!
  updateCluster(input: UpdateClusterInput!): Cluster!
  addCluster(input: AddClusterInput!): Cluster!
  linkCloudToCluster(input: LinkCloudToClusterInput!): Cluster!
  updateClusterDomain(input: UpdateClusterDomainInput!): Cluster!
  addContainerRegistry(input: AddContainerRegistryInput!): ContainerRegistry!
  removeContainerRegistry(id: UUID!): Boolean!
  addCoreWeaveAccount(input: AddCoreWeaveAccountInput!): CoreWeaveAccount!
  updateCoreWeaveAccount(input: UpdateCoreWeaveAccountInput!): Boolean!
  removeCoreWeaveAccount(id: UUID!): Boolean!
  createDatabase(input: CreateDatabaseInput): Repo!
  linkDatabase(input: LinkDatabaseInput!): Repo!
  unlinkDatabase(id: UUID!): Boolean
  updateDatabaseLink(input: updateDatabaseLinkInput!): Repo!
  createBlueprint(input: CreateBlueprintInput!): Blueprint!
  updateBlueprint(blueprintID: UUID!, input: UpdateBlueprintInput!): Blueprint!
  deleteBlueprint(id: UUID!): Boolean!
  createProjectV3(input: CreateProjectV3Input!): ProjectV3!
  updateProjectV3(projectID: UUID!, input: UpdateProjectV3Input!): ProjectV3!
  deleteProjectV3(id: UUID!): Boolean!
  configureGitopsForProjectV3(input: ProjectV3GitopsInput!): ProjectV3!
  commitProjectV3ToGithubRepo(projectID: UUID!): GithubCommitResult!
  executeBlueprintDriverAction(input: BlueprintDriverActionInput!): BlueprintDriverActionResult!
  addDOAccount(input: AddDOAccountInput!): DOAccount!
  updateDOAccount(input: UpdateDOAccountInput!): Boolean!
  removeDOAccount(id: UUID!): Boolean!
  addRepoCustomDomain(input: AddRepoCustomDomainInput!): Repo!
  removeRepoCustomDomain(input: RemoveRepoCustomDomainInput!): Repo!
  updateRepoCustomDomain(input: UpdateRepoCustomDomainInput!): Repo!
  reissueCustomDomainCertificate(input: ReissueCustomDomainCertificateInput!): Repo!
  createEventIntegration(input: CreateEventIntegrationInput!): EventIntegration!
  addGCPAccount(input: AddGCPAccountInput!): GCPAccount!
  updateGCPAccount(input: UpdateGCPAccountInput!): Boolean!
  removeGCPAccount(id: UUID!): Boolean!
  createGitlabIntegration(input: CreateGitlabIntegrationInput!): GitlabIntegration!
  updateGitlabIntegration(input: UpdateGitlabIntegrationInput!): GitlabIntegration!
  createProjectHelm(input: CreateProjectHelmInput): Repo!
  createSlackWebhookIntegration(input: CreateWebhookIntegrationInput!): SlackWebhookIntegration!
  updateSlackWebhookIntegration(input: UpdateWebhookIntegrationInput!): SlackWebhookIntegration!
  createDiscordWebhookIntegration(input: CreateWebhookIntegrationInput!): DiscordWebhookIntegration!
  updateDiscordWebhookIntegration(input: UpdateWebhookIntegrationInput!): DiscordWebhookIntegration!
  createDatadogIntegration(input: CreateDatadogIntegrationInput!): DatadogIntegration!
  removeUserIntegration(input: RemoveUserIntegrationInput!): Boolean!
  createIPFSService(input: CreateIPFSServiceInput!): IPFSService!
  runJob(input: RunJobInput!): JobRun!
  addLinodeAccount(input: AddLinodeAccountInput!): LinodeAccount!
  updateLinodeAccount(input: UpdateLinodeAccountInput!): Boolean!
  removeLinodeAccount(id: UUID!): Boolean!
  createManifestApp(input: CreateManifestAppInput): Repo!
  createProjectV2(input: CreateProjectV2Input!): Project!
  updateProjectV2(input: UpdateProjectV2Input!): Project!
  deleteProjectV2(id: UUID!): Boolean!
  createProjectEnvironment(input: CreateProjectEnvironmentInput!): ProjectEnvironment!
  updateProjectEnvironment(input: UpdateProjectEnvironmentInput!): ProjectEnvironment!
  deleteProjectEnvironment(id: UUID!): Boolean!
  moveRepoToProjectEnvironment(input: MoveRepoInput!): Repo!
  dispatchRepoGroupAction(input: dispatchRepoGroupActionInput!): Boolean
  duplicateProject(input: DuplicateProjectInput!): Repo!
  duplicateRepo(input: DuplicateRepoInput!): Repo!
  deleteProjectBranch(id: UUID!, branch: String!): Boolean!
  rollbackProjectToDeployment(projectID: UUID!, deploymentID: UUID!): Repo!
  updateProject(input: UpdateProjectInput!): Repo!
  updateProjectDanger(input: UpdateProjectDangerInput!): Repo!
  removeProbe(input: RemoveProbeInput!): Repo!
  removeLogShipper(id: UUID!): Boolean!
  migrateGithubConnection(id: UUID!, installationID: String!): Repo!
  createProject(input: CreateProjectInput): Repo!
  createProjectDocker(input: CreateProjectDockerInput): Repo!
  createProjectGit(input: CreateProjectGitInput): Repo!
  createResourceAlpha(input: CreateResourceAlphaInput!): Repo!
  createRepoPipelineLink(input: CreateRepoPipelineLinkInput!): RepoPipelineLink!
  updateRepoPipelineLink(input: UpdateRepoPipelineLinkInput!): RepoPipelineLink!
  deleteRepoPipelineLink(id: UUID!): Boolean
  createTeam(input: CreateTeamInput!): Team!
  deleteTeam(id: UUID!): Boolean!
  updateTeam(input: UpdateTeamInput!): Team!
  updateTeamMemberRole(input: UpdateTeamMemberRoleInput!): UserTeamEdge!
  addTeamMember(input: AddTeamMemberInput!): Team!
  removeTeamMember(input: RemoveTeamMemberInput!): Team!
  inviteTeamMember(input: InviteTeamMemberInput!): TeamMemberInvitation!
  acceptTeamMemberInvitation(token: String!): Team!
  resendTeamMemberInvitation(id: UUID!): Boolean!
  deleteTeamMemberInvitation(id: UUID!): Boolean!
  uploadDockerCompose(contents: String!): Template!
  createProjectsFromTemplate(input: CreateProjectsFromTemplateInput!): [Repo!]!
  freezeRepo(id: UUID!): Template!
  createProjectTerraform(input: CreateProjectTerraformInput): Repo!
  updateUser(input: UpdateUserInput!): User!
  deleteUser: Boolean!
  addVultrAccount(input: AddVultrAccountInput!): VultrAccount!
  updateVultrAccount(input: UpdateVultrAccountInput!): Boolean!
  removeVultrAccount(id: UUID!): Boolean!
  createWeb3Challenge(input: CreateWeb3ChallengeInput!): Web3Challenge!
  signInWithWeb3(input: SignInWithWeb3Input!): UserAuth!
}

type Network {
  id: ID!
  name: String!
  region: String!
  data: JSON
  cloud: CloudAccount
  clusters: [Cluster!]
  machines: [Machine]
}

scalar Object

type PageInfo {
  startCursor: String!
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PageInput {
  first: Int = 10
  last: Int
  after: String
  before: String
  filter: String
  sort: String
}

type PipelineStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type PipelineStep {
  id: UUID!
  logs: Logs
}

type Plan {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod
  stripeSubscription: StripeSubscription
}

enum PlanBillingPeriod {
  MONTHLY
  ANNUALLY
}

enum PlanTier {
  LEGACY
  BASIC
  PRO
}

type Port {
  port: String!
  protocol: String!
  public: Boolean!
  https: Boolean!
  grpc: Boolean!
  loadBalancer: Boolean!
}

input PortInput {
  port: String!
  protocol: PortProtocol!
  public: Boolean!
  https: Boolean!
  grpc: Boolean
}

enum PortProtocol {
  tcp
  udp
}

type PriceComponent {
  cost: Int!
  explanation: String!
}

type Prices {
  ramGB: Float!
  cpuCore: Float!
  dedicatedGPU: Float!
  dedicatedRamGB: Float!
  dedicatedCpuCore: Float!
  storageGB: Float!
}

type Probe {
  command: String
  http: HTTPProbe
  tcp: TCPProbe
  initialDelaySeconds: Int!
  periodSeconds: Int!
  successThreshold: Int!
  failureThreshold: Int!
  timeoutSeconds: Int!
}

input ProbeInput {
  command: String
  httpEndpoint: String
  tcpEndpoint: String
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  failureThreshold: Int
  timeoutSeconds: Int
}

interface ProfileOwner {
  login: Login!
  name: String!
  avatar: URL
}

type Project {
  id: UUID!
  name: String!
  envs: [EnvVar!]
  isMultiRepo: Boolean!
  defaultEnvironment: ProjectEnvironment!
  environment(id: UUID, name: String): ProjectEnvironment!
  environments: [ProjectEnvironment!]!
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  owner: User!
  createdAt: Time!
  updatedAt: Time!
}

input ProjectBuildInput {
  buildType: BuildType
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
}

type ProjectCollaborator {
  id: ID!
  user: User!
  role: ProjectCollaboratorRole!
}

type ProjectCollaboratorInvitation {
  id: ID!
  email: String!
  link: String!
  role: ProjectCollaboratorRole!
  project: Repo!
}

enum ProjectCollaboratorRole {
  OWNER
  EDITOR
  VIEWER
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge!]!
  nodes: [Project!]!
}

input ProjectDeployInput {
  deployTarget: DeployTarget!
  deployType: DeployType
  deployRuntime: DeployRuntime
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  clusterID: UUID
  region: String
}

type ProjectEdge {
  cursor: String!
  node: Project!
}

type ProjectEnvironment {
  id: UUID!
  name: String!
  envs: [EnvVar!]
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  repoConnection(page: PageInput, repoFilter: repoFilterInput): RepoConnection!
  overview: [EnvironmentOverview]
  project: Project
  createdAt: Time!
  updatedAt: Time!
}

interface ProjectOwner {
  projects(input: ProjectsInput): ProjectConnection!
}

input ProjectsInput {
  page: PageInput
}

type ProjectTemplate {
  id: ID!
  name: String!
  description: String!
  image: String!
  source: RepoSource!
  cpu: Float!
  memory: Float!
  envs: [EnvVarTemplate!]
  ports: [Port!]
  replication: [Replication!]
  volumes: [VolumeSpec!]
  gpu: Int
  dedicated: Boolean
}

type ProjectV3 {
  id: UUID!
  name: String!
  blueprintID: UUID!
  requirePlanApproval: Boolean!
  variables: [BlueprintVariable!]!
  project: Project
  projectEnvironment: ProjectEnvironment
  configuration: ProjectV3Configuration
  workflows: [ProjectV3Workflow!]
}

type ProjectV3Adapter {
  id: UUID!
  repo: Repo
  projectV3: ProjectV3
  name: String!
  status: ProjectV3AdapterStatus
  project: Project
  projectEnvironment: ProjectEnvironment
  createdAt: Time!
  updatedAt: Time!
}

type ProjectV3AdapterConnection {
  nodes: [ProjectV3Adapter!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

enum ProjectV3AdapterStatus {
  UNKNOWN
  JOB_RUN_STARTING
  JOB_RUN_RUNNING
  JOB_RUN_FAILED
  JOB_RUN_SUCCEEDED
  JOB_RUN_CANCELLED
  JOB_RUN_PENDING_APPROVAL
  DEPLOY_PENDING
  DEPLOY_IN_PROGRESS
  DEPLOY_FAILED
  DEPLOY_SUCCEEDED
  DEPLOY_STOPPED
  DEPLOY_HEALTHY
  DEPLOY_CRASHING
  BUILD_PENDING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
  BUILD_ABORTED
}

union ProjectV3Configuration = TerraformProjectV3Configuration | HelmProjectV3Configuration | ManifestProjectV3Configuration

type ProjectV3Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  nodes: [ProjectV3!]!
}

input ProjectV3GitopsInput {
  projectID: UUID!
  githubConnectionID: Int!
  githubRepoOwner: String!
  githubRepoName: String!
  githubRepoID: String!
  subdirectoryPath: String
}

type ProjectV3Workflow {
  state: JobRunState!
  jobs: [BlueprintDriverActionExecution!]
  createdAt: Time!
  updatedAt: Time!
}

type Prometheus {
  url: String!
  user: String
  password: String
  token: String
}

type PrometheusScrape {
  path: String!
  port: Int!
}

input PrometheusScrapeInput {
  path: String!
  port: Int!
}

type Query {
  currentUser: User!
  user(id: ID!): User!
  team(id: UUID, path: String): Team
  project(id: UUID, path: String): Project
  repo(id: UUID, path: String): Repo
  dockerRepository(image: String!): DockerRepository
  checkPrice(input: CheckPriceInput!): CheckPriceOutput!
  prices: Prices!
  awsCostByService(awsAccountId: UUID!, where: CostByServiceWhere!): [Cost!]!
  awsCostUsage2(awsAccountId: UUID!, where: CostUsageWhere!): [Cost!]!
  blueprint(id: UUID!): Blueprint
  blueprintsMarketplace: BlueprintsMarketplace
  searchHelmCharts(input: SearchHelmChartsInput!): HelmChartConnection!
  helmRepository(url: String!): HelmRepository!
  template(id: UUID, slug: String, url: String): Template!
  terraformRegistry(url: URL): TerraformRegistry!
}

input ReissueCustomDomainCertificateInput {
  id: UUID!
}

type Release {
  id: UUID!
  logs: Logs
}

input RemoveProbeInput {
  id: ID!
  readinessProbe: Boolean
  livenessProbe: Boolean
  startupProbe: Boolean
}

input RemoveRepoCustomDomainInput {
  id: UUID!
  domainID: UUID!
}

input RemoveTeamMemberInput {
  id: UUID!
  userID: UUID!
}

input RemoveUserIntegrationInput {
  userID: UUID!
  id: UUID!
}

type Replication {
  region: String!
  replicas: Int
  cluster: Cluster
}

input ReplicationInput {
  region: String!
  replicas: Int!
  clusterID: UUID
}

type Repo {
  id: ID!
  name: String!
  source: RepoSource!
  appID: String
  enabled: Boolean!
  namespace: String
  kappID: String
  clusterDomains: [ClusterDomains!]
  cdns: [CDN!]
  envs: [EnvVar!]
  replication: [Replication!]
  ports: [Port!]
  volumes: [VolumeSpec!]
  secretMounts: [KubernetesSecretMount!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  buildMethod: BuildMethod
  buildMethodSuggestions: [BuildMethod!]
  noBuildCache: Boolean
  kanikoFlags: KanikoFlags
  resources: ContainerResourcesSpec
  buildResources: ContainerResourcesSpec
  branchResources: ContainerResourcesSpec
  serverlessResources: ServerlessResourceSpec
  serverlessRegion: String
  readinessProbe: Probe
  livenessProbe: Probe
  startupProbe: Probe
  autoscaling: Autoscaling
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  staticIP: Boolean
  deployments(first: Int = 10, after: String, input: DeploymentsInput): [Deployment!]
  deployment(id: ID!): Deployment
  branches: [RepoBranch!]
  branch(id: UUID, name: String): RepoBranchV2
  productionBranchV2: RepoBranchV2
  branchesV2(page: PageInput, input: BranchInput): RepoBranchConnection
  productionBranch: String
  productionDeployment: Deployment
  githubRepository: GitHubRepository
  githubIntegration: GitHubRepoIntegration
  gitlabIntegration: GitlabRepoIntegration
  helmChart: HelmChart
  helmValues: String
  terraformVersion: String
  terraformVariables: JSON
  image: String
  collaborators: [ProjectCollaborator!]
  collaboratorInvitations: [ProjectCollaboratorInvitation!]
  free: Boolean
  prometheusScrape: PrometheusScrape
  logShipper: LogShipper
  kubernetesCustomization: KubernetesCustomization
  deployTarget: DeployTarget
  deployType: DeployType
  canDeploy: Boolean
  cluster: Cluster
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  awsIamRole: String
  gcpServiceAccount: String
  deployStrategy: DeployStrategy
  deployService: Boolean
  deployJob: Boolean
  cronJobSchedule: String
  jobRun(id: UUID!): JobRun!
  jobRuns: JobRunConnection
  hasBuildStage: Boolean
  hasDeployStage: Boolean
  alternativeImageTagTemplates: [String!]
  containerRegistry: ContainerRegistry
  databaseProvider: DatabaseProviderType
  databaseEngine: DatabaseEngineType
  databaseVersion: String
  databaseLinks: [DatabaseLink!]!
  linkedProjects: [DatabaseLink!]!
  databaseEnvs: [EnvVar!]!
  disableReason: DisableReason
  datadogApmEnabled: Boolean
  pipelineCluster: Cluster
  defaultIngressDomain: String
  project: Project
  projectEnvironment: ProjectEnvironment
  owner: User!
  createdAt: Time!
  updatedAt: Time!
  buildSpec: ContainerSpec
  cpu: String
  memory: String
  gpu: GPUSpec
  tpu: TPUSpec
  ephemeralStorage: Float
  dedicated: Boolean
  deployBranch: Boolean
  branchIgnore: String
  nodeSelector: JSON
  hostNetwork: Boolean
  clusterIssuerName: String
  path: String!
  fullPath: String!
  manifest: Manifest
  pipelineLinks: [RepoPipelineLink!]
  machines: [Machine!]
}

enum RepoAction {
  DEPLOY
}

input RepoActionInput {
  action: RepoAction!
  setImage: String
}

type RepoBranch {
  id: ID!
  name: String!
  state: String
  updatedAt: Time
  deployments: [Deployment!]
}

type RepoBranchConnection {
  totalCount: Int!
  nodes: [RepoBranchV2!]!
  pageInfo: PageInfo!
}

type RepoBranchV2 {
  id: UUID!
  name: String!
  state: String
  status: String
  environmentSlug: String
  branchSlug: String
  latestDeployment: Deployment
  deployments(page: PageInput): DeploymentConnection
  endpoints: [String!]
  privateEndpoints: [String!]
  loadBalancers: [LoadBalancer!]
  metrics(name: String!): [Metric!]
  image: String
  namespace: String
  kappID: String
  patchedPodSpec: String
  renderPodSpec(patch: String): String
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  repo: Repo
  createdAt: Time!
  updatedAt: Time!
  resources: [CloudResource!]
}

type RepoConnection {
  totalCount: Int!
  nodes: [Repo!]!
  pageInfo: PageInfo!
}

enum RepoEvent {
  BUILD_SUCCEEDED
  DEPLOY_SUCCEEDED
}

input RepoFilter {
  status: RepoStatusCriterion
}

input repoFilterInput {
  deploymentStatus: [DeploymentStatus]
}

type RepoGroup {
  id: UUID!
  name: String
  description: String
  selector: LabelSelectors
  repos: [Repo!]
}

type RepoPipelineLink {
  id: UUID!
  source: Repo!
  sourceEvent: RepoEvent!
  targetGroup: RepoGroup!
  targetAction: RepoAction!
}

input ReposInput {
  first: Int = 10
  after: String
  team: ID
  showDisabled: Boolean = false
}

type RepoSource {
  id: ID!
  type: RepoSourceType!
  name: String!
}

enum RepoSourceType {
  GITHUB
  GITHUB_PUBLIC
  GITLAB
  GIT
  DOCKER
  DOCKER_HUB
  HELM
  TERRAFORM
}

input RepoStatusCriterion {
  value: String
  operator: FilterCriterionOperatorType
}

input ResourceAdapterFilter {
  ids: MultiEntityCriterion
  repoIds: MultiEntityCriterion
  resourceIds: MultiEntityCriterion
  deployableIds: MultiEntityCriterion
  name: StringCriterion
  status: AdapterStatusCriterion
  projectName: StringCriterion
  environmentName: StringCriterion
}

input ResourceBranchInput {
  productionBranch: String
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

input ResourceBuildInput {
  build: ProjectBuildInput
  buildTarget: BuildTargetInput
  buildResources: ContainerResourcesSpecInput
  kanikoFlags: KanikoFlagsInput
  noBuildCache: Boolean
  containerRegistryID: UUID
  containerCacheRepository: String
  containerRepository: String
}

input ResourceDatabaseInput {
  deployTarget: DatabaseDeployTargetInput!
  engine: DatabaseEngineType!
  version: String!
  options: DatabaseOptions
}

input ResourceFilter {
  ids: MultiEntityCriterion
  deployableIds: MultiEntityCriterion
  userIds: MultiEntityCriterion
}

input ResourceKubernetesAppInput {
  deployJob: Boolean
  deployService: Boolean
  releaseCommand: String
  envs: [EnvVarInput!]
  runCommand: String
  volumes: [VolumeInput!]
  secretMounts: [KubernetesSecretMountInput!]
  ports: [PortInput!]
  defaultIngressDomain: String
  staticIP: Boolean
  resources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  replication: [ReplicationInput]
  autoscaling: AutoscalingInput
  logShipper: LogShipperInput
  datadogApmEnabled: Boolean
  prometheusScrape: PrometheusScrapeInput
  deployStrategy: DeployStrategy
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  awsIamRole: String
  gcpServiceAccount: String
  customization: KubernetesCustomizationInput
}

input ResourceKubernetesHelmInput {
  releaseName: String
  values: YAML
  valuesFiles: [String]
}

input ResourceKubernetesInput {
  deployTarget: ProjectDeployInput
  namespace: String
  app: ResourceKubernetesAppInput
  manifest: ResourceKubernetesManifestInput
  helm: ResourceKubernetesHelmInput
}

input ResourceKubernetesManifestInput {
  manifestValue: YAML
  manifests: [String]
  kustomizeDirs: [String]
}

input ResourceServerlessInput {
  deployService: Boolean
  deployTarget: ProjectDeployInput
  envs: [EnvVarInput]
  ports: [PortInput!]
  serverlessResources: ServerlessResourcesSpecInput
}

input ResourceTerraformInput {
  deployTarget: ProjectDeployInput
  variables: JSON
}

input ResourceWorkflowInput {
  autoRetry: Boolean
  autoRollback: Boolean
  manualDeploy: Boolean
  pipelineClusterID: UUID
}

type RightSizingInstance {
  name: String
  monthlyCost: String
  hourlyCost: String
  type: String
  memory: String
  storage: String
  vcpu: String
  utilization: RightSizingUtilization
  resourceId: String
}

type RightSizingRecommendation {
  currentInstance: RightSizingInstance
  recommendations: [RightSizingRecommendationDetail!]
  reasons: [String!]!
}

type RightSizingRecommendationDetail {
  estimatedMonthlyCost: String
  estimatedMonthlySavings: String
  platformDifferences: [String]
  instance: RightSizingInstance
}

type RightSizingUtilization {
  maxCpuUtilizationPercentage: String
  maxMemoryUtilizationPercentage: String
  maxStorageUtilizationPercentage: String
}

input RunJobInput {
  id: UUID!
  runCommand: String
  envs: [EnvVarInput!]
  build: Boolean
}

union Runtime = CloudRuntime | KubernetesRuntime

input S3BucketBackendInput {
  awsAccountID: UUID!
  bucketName: String!
  region: String!
}

enum SavingsPlanPaymentOption {
  NO_UPFRONT
  PARTIAL_UPFRONT
  ALL_UPFRONT
  LIGHT_UTILIZATION
  MEDIUM_UTILIZATION
  HEAVY_UTILIZATION
}

type SavingsPlanRecommendation {
  currentOnDemandSpend: String
  estimatedSavingsAmount: String
  estimatedSavingsPercentage: String
  estimatedOnDemandCostWithCurrentCommitment: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
  details: [SavingsPlanRecommendationDetail!]
}

type SavingsPlanRecommendationDetail {
  instanceFamily: String
  offeringId: String
  region: String
  currentAverageHourlyOnDemandSpend: String
  estimatedAverageUtilization: String
  upfrontCost: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
}

input SavingsPlanRecommendationsInput {
  paymentOption: SavingsPlanPaymentOption!
  type: SavingsPlanType!
  term: SavingsPlanTerm!
}

enum SavingsPlanTerm {
  ONE_YEAR
  THREE_YEARS
}

enum SavingsPlanType {
  COMPUTE_SP
  EC2_INSTANCE_SP
  SAGEMAKER_SP
}

input SearchHelmChartsInput {
  first: Int
  after: String
  query: String
}

type ServerlessConfig {
  service: String
  provider: ServerlessProvider
  functions: [ServerlessFunction!]
  awsStackName: String
}

type ServerlessFunction {
  name: String!
  handler: String
}

type ServerlessProvider {
  name: String
  runtime: String
  stage: String
  region: String
  stackName: String
}

type ServerlessResourceSpec {
  cpu: Float
  memory: Float
}

input ServerlessResourcesSpecInput {
  cpu: Float
  memory: Float!
}

input SetRepoEnvsInput {
  id: ID!
  envs: [EnvVarInput!]!
}

input SignInWithWeb3Input {
  challengeId: UUID!
  signature: String!
}

type SlackIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type SlackWebhookIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
}

enum SortDirection {
  ASC
  DESC
}

input SortInput {
  direction: SortDirection
  field: String
}

type Source {
  git: GitSource
  terraformRegistry: TerraformRegistrySource
  helmRepository: HelmRepositorySource
  containerRegistry: ContainerRegistrySource
}

input SourceInput {
  git: GitSourceInput
  terraformRegistry: TerraformRegistrySourceInput
  helmRepository: HelmRepositorySourceInput
  containerRegistry: ContainerRegistrySourceInput
}

input StringCriterion {
  value: String
  operator: FilterCriterionOperatorType
}

type StripePrice {
  id: ID!
  product: StripeProduct!
  unitAmount: Int!
}

type StripeProduct {
  id: ID!
  name: String!
  description: String!
}

type StripeSubscription {
  id: ID!
  status: StripeSubscriptionStatus!
  items: [StripeSubscriptionItem!]!
  createdAt: Time!
}

type StripeSubscriptionItem {
  id: ID!
  price: StripePrice!
  quantity: Int!
}

enum StripeSubscriptionStatus {
  active
  past_due
  unpaid
  canceled
  incomplete
  incomplete_expired
  trialing
}

type StripeUser {
  id: ID!
  balance: Int!
}

type Subscription {
  repoUpdated(id: UUID!): Repo!
  deploymentUpdated(id: ID!): Deployment!
  deploymentBuildLogsAdded(input: BuildLogsInput!): LogEntry!
}

input SuggestProjectNameInput {
  name: String
  type: String
}

input SuggestTemplateNameInput {
  id: ID!
  name: String
}

type SyslogIntegration {
  host: String!
  port: String!
  mode: String!
}

input SyslogIntegrationInput {
  host: String!
  port: String!
  mode: String!
}

type TCPProbe {
  host: String
  port: String!
}

type Team implements ProfileOwner & ProjectOwner {
  id: UUID!
  login: Login!
  name: String!
  avatar: URL
  user: User!
  awsAccounts: [AWSAccount!]
  parent: Team
  children: [Team!]
  members: [UserTeamEdge!]!
  memberInvitations: [TeamMemberInvitation!]!
  projects(input: ProjectsInput): ProjectConnection!
  plan: Plan!
}

type TeamMemberInvitation {
  id: UUID!
  team: Team!
  role: TeamMemberRole!
  link: String!
  email: String
  expiresAt: Time
  createdAt: Time!
}

enum TeamMemberRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

type Template {
  id: ID!
  name: String!
  description: String!
  image: String!
  homepageURL: String
  repositoryURL: String
  stats: TemplateStats
  projects: [ProjectTemplate!]!
}

type TemplateStats {
  deploys: Int!
  forks: Int!
  stars: Int!
}

"""Input values for Terraform APPLY actions"""
input TerraformApplyActionParameters {
  """Zeet ID for the driver action execution of a Terraform PLAN action"""
  planID: UUID!
}

"""Input values for Terraform APPROVE actions"""
input TerraformApproveActionParameters {
  """Zeet ID for the driver action execution of a Terraform PLAN action"""
  planID: UUID!
}

type TerraformModule {
  id: ID!
  owner: String
  namespace: String
  name: String
  version: String
  provider: String
  description: String
  source: String
  publishedAt: Time
  downloads: Int
  verified: Boolean
  registry: TerraformRegistry!
}

type TerraformModuleConnection {
  totalCount: Int!
  nodes: [TerraformModule!]!
  pageInfo: PageInfo!
}

type TerraformOperation {
  id: UUID!
  state: TerraformOperationState!
  approved: Boolean!
  config: JSON
  planStage: PipelineStage
  applyStage: PipelineStage
}

enum TerraformOperationState {
  PENDING
  PLANNING
  WAITING_FOR_APPROVAL
  APPLYING
  PLAN_FAILED
  APPLY_FAILED
  CANCELED
  SUCCEEDED
}

"""Input values for Terraform PLAN actions"""
input TerraformPlanActionParameters {
  """Zeet ID for a connected AWS Account"""
  awsAccountID: UUID

  """Zeet ID for a connected GCP Account"""
  gcpAccountID: UUID

  """Zeet ID for a connected DigitalOcean Account"""
  doAccountID: UUID

  """Region name, when applicable"""
  region: String
}

"""Input values for Terraform PLAN_DESTROY actions"""
input TerraformPlanDestroyActionParameters {
  """Zeet ID for a connected AWS Account"""
  awsAccountID: UUID

  """Zeet ID for a connected GCP Account"""
  gcpAccountID: UUID

  """Zeet ID for a connected DigitalOcean Account"""
  doAccountID: UUID

  """Region name, when applicable"""
  region: String
}

type TerraformProjectV3Configuration {
  stateBackend: TerraformStateBackend!
}

input TerraformProjectV3ConfigurationInput {
  stateBackend: TerraformStateBackendInput!
}

type TerraformRegistry {
  id: ID!
  url: URL
  module(id: ID!): TerraformModule!
}

type TerraformRegistrySource {
  source: String!
  version: String
}

input TerraformRegistrySourceInput {
  source: String!
  version: String
}

type TerraformStateBackend {
  awsAccount: UUID
  gcpAccount: UUID
  region: String
}

input TerraformStateBackendInput {
  s3Bucket: S3BucketBackendInput
  gcsBucket: GCSBucketBackendInput
}

scalar Time

enum TimeFilter {
  Monthly
  Daily
}

type TimePeriod {
  startAt: Time!
  endAt: Time!
}

input TPUInput {
  type: String!
  cores: Int!
  tfVersion: String!
}

type TPUSpec {
  tfVersion: String!
  type: String!
  cores: Int!
}

input TransferProjectInput {
  id: ID!
  to: ID!
}

input UpdateAWSAccountInput {
  id: UUID!
  name: String
}

input UpdateAzureAccountInput {
  id: UUID!
  name: String
  subscriptionID: String
  tenantID: String
  clientID: String
  clientSecret: String
}

input UpdateBlueprintInput {
  displayName: String
  published: Boolean
  slug: String
  configuration: BlueprintConfigurationUpdate
  richInputSchema: JSON
}

input UpdateBranchInput {
  id: UUID
  repoID: UUID
  name: String
  image: String
  githubSha: String
  build: Boolean
  deploy: Boolean
}

input UpdateCDNInput {
  id: UUID!
  domains: [String!]
}

input UpdateClusterAddOn {
  slug: String!
  state: ClusterAddOnState!
  helmValues: YAML
}

input UpdateClusterDomainInput {
  domain: String!
  clusterID: UUID!
}

input UpdateClusterInput {
  id: UUID!
  kubeconfig: Upload
  name: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID

  """
  The new configuration for cluster add-ons. When this field is provided (i.e. not-null), it must include
  _all_ cluster add-ons present in `Cluster.addOns`, even if some of the add-ons are not being modified.
  
  This is because once an add-on is added to a cluster, it cannot be _removed_, only _disabled_.
  """
  addOns: [UpdateClusterAddOn!]
}

input UpdateCoreWeaveAccountInput {
  id: UUID!
  name: String
}

input updateDatabaseLinkInput {
  id: UUID!
  envPrefix: String
}

input UpdateDOAccountInput {
  id: UUID!
  name: String
}

input UpdateGCPAccountInput {
  id: UUID!
  name: String
}

input UpdateGitlabIntegrationInput {
  id: UUID!
  name: String
  apiUrl: URL
  accessToken: String
}

input UpdateIPFSServiceInput {
  id: UUID!
  accessToken: String
}

input UpdateLinodeAccountInput {
  id: UUID!
  name: String
}

input UpdateProjectDangerInput {
  id: UUID!
  namespace: String
  appID: String
  defaultIngressDomain: String
  deployTarget: ProjectDeployInput
}

input UpdateProjectEnvironmentInput {
  id: UUID!
  name: String
  envs: [EnvVarInput!]
}

input UpdateProjectInput {
  id: ID!
  path: String
  name: String
  dockerImage: String
  githubIntegration: GitHubRepoIntegrationInput
  gitlabIntegration: GitlabRepoIntegrationInput
  buildType: String
  dockerfilePath: String
  dockerfileText: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  releaseCommand: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
  noBuildCache: Boolean
  kanikoFlags: KanikoFlagsInput
  alternativeImageTagTemplates: [String!]
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  serverlessResources: ServerlessResourcesSpecInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  hostNetwork: Boolean
  staticIP: Boolean
  iamPolicies: [String!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployStrategy: DeployStrategy
  helmVersion: String
  helmValues: String
  terraformVersion: String
  terraformVariables: String
  manifests: [String!]
  manifestValue: String
  manifest: ResourceKubernetesManifestInput
  awsIamRole: String
  gcpServiceAccount: String
  clusterIssuerName: String
  logShipper: LogShipperInput
  deployService: Boolean
  deployJob: Boolean
  cronJobSchedule: String
  productionBranch: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  nodeSelector: JSON
  secretMounts: [KubernetesSecretMountInput!]
  kubernetesCustomization: KubernetesCustomizationInput
  buildCPU: Float
  buildMemory: Float
  cpu: String
  memory: String
  ephemeralStorage: Float
  gpu: GPUInput
  tpu: TPUInput
  dedicated: Boolean
  githubInstallationID: String
  githubRepository: String
  deployBranch: Boolean
  branchIgnore: String
  datadogApmEnabled: Boolean
  pipelineClusterID: UUID
  deployTarget: ProjectDeployInput
}

input UpdateProjectV2Input {
  id: UUID!
  name: String
  envs: [EnvVarInput!]
}

input UpdateProjectV3Input {
  name: String
  requirePlanApproval: Boolean
  variables: [BlueprintVariableInput!]
  projectID: UUID
  environmentID: UUID
}

input UpdateRepoCustomDomainInput {
  id: UUID!
  disableCertManager: Boolean
  certManagerChallengerType: CertManagerChallengeType
  syncDomainID: UUID
}

input UpdateRepoPipelineLinkInput {
  id: UUID!
  sourceEvent: RepoEvent
  targetRepoID: UUID
  targetEnvironmentID: UUID
  targetAction: RepoAction
}

input UpdateTeamInput {
  id: UUID!
  plan: UpdateTeamPlanInput
  paymentMethod: String
}

input UpdateTeamMemberRoleInput {
  id: UUID!
  role: TeamMemberRole!
}

input UpdateTeamPlanInput {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod!
}

input UpdateUserInput {
  id: UUID!
  avatar: URL
  login: String
  name: String
  email: String
}

input UpdateVultrAccountInput {
  id: UUID!
  name: String
}

input UpdateWebhookIntegrationInput {
  userID: UUID!
  id: UUID!
  url: String!
}

scalar Upload

scalar URL

type User implements ProfileOwner & ProjectOwner {
  id: ID!
  login: Login!
  name: String!
  avatar: URL
  isTeam: Boolean
  canDeploy: Boolean
  hasZeetCloud: Boolean
  hasOnboarded: Boolean
  advanced: Boolean
  email: String
  billingEmail: String
  createdAt: Time
  hasPaymentMethod: Boolean
  needsPaymentMethod: Boolean
  billingURL: String
  stripe: StripeUser
  freeQuota: Int
  freeTrialEndsAt: Time
  freeLimitExceeded: Boolean
  paymentError: String
  paymentAuthorizationError: String
  teams: [UserTeamEdge!]
  team(id: ID!): Team
  repos(first: Int = 10, after: String, input: ReposInput): [Repo!]
  repo(id: ID!): Repo
  projects(input: ProjectsInput): ProjectConnection!
  deployment(id: ID!): Deployment
  githubInstallations: [GitHubInstallation!]
  githubRepositories(installationID: ID!): [GitHubRepository!]
  githubRepository(installationID: ID!, owner: String!, repo: String!): GitHubRepository
  dockerRepository(image: String!): DockerRepository
  suggestProjectName(input: SuggestProjectNameInput!): String!
  checkProjectName(input: CheckProjectNameInput!): Boolean!
  suggestTemplateName(input: SuggestTemplateNameInput!): String!
  awsAccount(id: UUID!): AWSAccount
  awsAccounts: [AWSAccount!]
  gcpAccount(id: UUID!): GCPAccount
  gcpAccounts: [GCPAccount!]
  doAccount(id: UUID!): DOAccount
  doAccounts: [DOAccount!]
  linodeAccount(id: UUID!): LinodeAccount
  linodeAccounts: [LinodeAccount!]
  vultrAccount(id: UUID!): VultrAccount
  vultrAccounts: [VultrAccount!]
  coreweaveAccount(id: UUID!): CoreWeaveAccount
  coreweaveAccounts: [CoreWeaveAccount!]
  cloudAccount(id: ID!): CloudAccount
  jobRun(id: UUID!): JobRun!
  cluster(id: UUID!): Cluster
  clusters: [Cluster!]
  defaultCluster: Cluster
  apiKeys: [APIKey!]
  containerRegistries: [ContainerRegistry!]
  integrations: [Integration!]
  ipfsServices: [IPFSService!]
  azureAccount(id: UUID!): AzureAccount
  azureAccounts: [AzureAccount!]
  blueprints(page: PageInput): BlueprintConnection
  projectV3(id: UUID!): ProjectV3
  projectV3s(filter: FilterInput!): ProjectV3Connection
  projectV3DriverActionExecutions(filter: FilterInput!): BlueprintDriverActionExecutionConnection
  projectV3Adapters(filter: FilterInput!): ProjectV3AdapterConnection
  eventIntegrations: [EventIntegration!]
}

enum UserAction {
  READ_PRIVATE
  EDIT_BILLING
}

type UserAuth {
  authToken: String!
}

input UserFilter {
  ids: MultiEntityCriterion
}

type UserIamConnection {
  userId: String!
  awsIamArn: String!
  awsAccountId: String!
  id: UUID!
}

type UserTeamEdge {
  id: UUID!
  user: User!
  team: Team!
  role: TeamMemberRole!
}

scalar UUID

scalar VariableValueInput

type Volume {
  id: ID!
  spec: VolumeSpec!
}

input VolumeInput {
  mountPath: String!
  size: Int!
}

type VolumeSpec {
  size: Int!
  mountPath: String!
}

type VultrAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  accessToken: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type Web3Challenge {
  id: UUID!
  address: String!
  nonce: String!
}

scalar YAML

