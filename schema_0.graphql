"""
The @defer directive may be specified on a fragment spread to imply
de-prioritization, that causes the fragment to be omitted in the initial
response, and delivered as a subsequent response afterward. A query with @defer
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred
delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @enforceUserAction(action: UserAction!) on FIELD_DEFINITION

directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

"""
The @specifiedBy built-in directive is used within the type system definition
language to provide a scalar specification URL for specifying the behavior of
custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR

type AcceleratorSpec {
  type: String
  count: Int
  tpuTfVersion: String
}

input AcceleratorSpecInput {
  type: String!
  count: Int!
  tpuTfVersion: String
}

input AdapterStatusCriterion {
  value: [String]
}

input AddAWSAccountInput {
  userID: UUID!
  accountID: String!
}

input AddAzureAccountInput {
  userID: UUID!
  name: String
  subscriptionID: String!
  tenantID: String!
  clientID: String!
  clientSecret: String!
}

input AddCDNInput {
  id: UUID!
  provider: CDNProvider!
  domains: [String!]
}

input AddClusterInput {
  userID: UUID!
  kubeconfig: Upload
  awsAccountID: UUID
  gcpAccountID: UUID
  name: String
  region: String
  isPlaceholder: Boolean
}

input AddContainerRegistryInput {
  userID: UUID!
  name: String!
  registry: String!
  username: String!
  password: String!
}

input AddCoreWeaveAccountInput {
  userID: UUID!
  kubeconfig: Upload
}

input AddDOAccountInput {
  userID: UUID!
  name: String
  accessToken: String!
}

input AddGCPAccountInput {
  userID: UUID!
  projectID: String!
  credentials: Upload!
}

input AddLinodeAccountInput {
  userID: UUID!
  name: String
  accessToken: String!
}

input AddProjectCollaboratorInput {
  id: ID!
  user: String!
  role: ProjectCollaboratorRole!
}

input AddRepoCustomDomainInput {
  id: UUID!
  domain: String!
  certManagerChallengerType: CertManagerChallengeType
  syncDomainID: UUID
}

input AddTeamMemberInput {
  id: UUID!
  username: String
  userID: UUID
  role: TeamMemberRole!
}

input AddVultrAccountInput {
  userID: UUID!
  name: String!
  accessToken: String!
}

type AlternativeImage {
  reference: String
  tag: String
  name: String
}

type ApiAccess implements Product {
  name: String
  description: String
  sku: ID!
  displayPrice: String
  usage: [Usage!]!
  benefits: [String!]!
  productTypeMetadata: ProductTypeMetadata
}

type APIKey {
  id: UUID!
  token: String!
  name: String!
  description: String!
  createdAt: Time!
}

input AttachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

type AttachedAwsIamPolicy {
  arn: String!
  policyName: String!
  groupName: String!
}

type Autoscaling {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTrigger!]
  kedaScaledObjectSpec: String
}

input AutoscalingInput {
  minReplicas: Int!
  maxReplicas: Int!
  coolDownPeriod: Int
  triggers: [AutoscalingTriggerInput!]
  kedaScaledObjectSpec: String
}

type AutoscalingTrigger {
  type: AutoscalingType!
  spec: YAML!
}

input AutoscalingTriggerInput {
  type: AutoscalingType!
  spec: YAML!
}

enum AutoscalingType {
  CPU
  MEMORY
  PROMETHEUS
  CUSTOM
}

type AWSAccount {
  id: UUID!
  name: String!
  state: AWSAccountState!
  connected: Boolean
  accountID: String
  roleARN: String
  externalID: String
  cloudFormationURL: String!
  cloudFormationReadOnlyURL: String!
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  iamUsers: [AwsUser!]
  userIamConnections: [UserIamConnection!]
  awsIamPolicies: [AwsIamPolicy!]
  awsPolicyJson(input: awsPolicyJsonInput!): AwsPolicyJson
  cloudQuery: CloudQueryService
  costs(input: AwsCostsInput!): [AwsCostItem!]!
  costsByService(input: AwsCostsByServiceInput!): [GroupedAwsCostItem!]!
  savingsPlanRecommendations(input: SavingsPlanRecommendationsInput!): SavingsPlanRecommendation
  rightSizingRecommendations: [RightSizingRecommendation!]
  awsResources(input: AwsResourceSearchInput): AwsResourcesOutput!
  networks: [Network!]
}

enum AWSAccountState {
  WAITING
  SUCCESS
  ERROR
}

type AwsCostItem {
  timePeriod: TimePeriod!
  total: AwsCostTotal!
}

input AwsCostsByServiceInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
  services: [String!]!
}

input AwsCostsInput {
  includeCredit: Boolean!
  timeFilter: TimeFilter!
  startAt: Time!
  endAt: Time!
}

type AwsCostTotal {
  amount: String!
  unit: String!
}

type AwsIamPolicy {
  arn: String!
  policyName: String!
  awsAccountId: String!
}

type AWSLambda {
  id: UUID!
  name: String!
  region: String
  awsAccount: AWSAccount
  arn: String
  apiGatewayUrl: String
}

type AWSLinks {
  cloudformation: String
  lambda: String
  apiGateway: String
  cloudwatchMetrics: String
  cloudwatchLogs: String
  eks: String
  rds: String
  ec2: String
  vpc: String
  iam: String
}

type AwsPolicyJson {
  awsPolicyJson: JSON!
}

input awsPolicyJsonInput {
  arn: String
  username: String
  policyName: String
}

type AwsRegionStatus {
  enabled: Boolean!
  region: String!
  regionName: String
  message: String
}

type AwsResource {
  arn: String!
  type: String!
  region: String
}

input AwsResourceSearchInput {
  region: String
  tag: String
  nextToken: String
}

type AwsResourcesOutput {
  awsResources: [AwsResource!]
  nextToken: String
}

type AwsSamGeneratorConfiguration {
  envVars: [EnvVar!]
  runCommand: String
  serverlessMemory: Int
  serverlessArch: String
  customDomainHost: String
  customDomainCertificateArn: String
  httpPort: String
  buildImage: String
}

input AwsSamGeneratorConfigurationInput {
  envVars: [EnvVarInput]
  runCommand: String
  serverlessMemory: Int
  serverlessArch: String
  customDomainHost: String
  customDomainCertificateArn: String
  httpPort: String
  buildImage: String
}

type AwsSamProjectV3Configuration {
  awsAccountId: UUID!
  awsRegion: String
  stackName: String!
  generator: AwsSamGeneratorConfiguration
}

input AwsSamProjectV3ConfigurationInput {
  awsAccountId: UUID!
  awsRegion: String
  stackName: String!
  generator: AwsSamGeneratorConfigurationInput
}

type AwsServiceCostItem {
  service: String!
  total: AwsCostTotal!
}

type AwsUser {
  arn: String!
  userId: String!
  username: String!
  awsAccountId: String!
  attachedAwsPolicies: [AttachedAwsIamPolicy]!
}

type AzureAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  connected: Boolean
  subscriptionID: String
  tenantID: String
  clientID: String
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
}

type BetterStackIntegration {
  token: String!
}

input BetterStackIntegrationInput {
  token: String!
}

"""
A sentinel value returned when we are not able to facilitate self-service for a desired action
"""
enum BillingActionNotAllowed {
  """Please contact Zeet Support for assistance"""
  CONTACT_US

  """You are not authorized to perform this billing action"""
  CONTACT_BILLING_ADMINISTRATOR
}

type BillingOverview {
  currentProducts: [Product!]
  externalLinks: ExternalBillingProviderLinks
  subscriptionUsageAllowed: SubscriptionUsageAllowed!
  subscriptionFeatures: SubscriptionFeatures!
}

type BitbucketAccount {
  username: String!
}

type BitbucketIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiUrl: URL!
  authType: BitbucketIntegrationAuthType!
  webhookUrl: URL!
  webhookToken: String!
  connected: Boolean
  account: BitbucketAccount
}

enum BitbucketIntegrationAuthType {
  ACCESS_TOKEN
  OAUTH2
}

type BitbucketRepoIntegration implements GitRepoIntegration {
  id: UUID!
  bitbucketIntegration: BitbucketIntegration
  bitbucketRepository: BitbucketRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

type BitbucketRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

type Blueprint {
  id: UUID!
  slug: String!
  displayName: String!
  published: Boolean!
  type: BlueprintType!
  isOfficial: Boolean
  enabled: Boolean
  docsUrl: String
  description: String
  tags: [String!]!
  logoUrl: String
  configuration: BlueprintConfiguration
  variables: [BlueprintVariableSpec!]!
  projectCount: Int!
  richInputSchema: JSON
  allowedCloudProviders: [CloudProvider!]!
  owner: BlueprintOwner
}

union BlueprintConfiguration = BlueprintTerraformConfiguration | BlueprintManifestConfiguration | BlueprintHelmConfiguration

input BlueprintConfigurationInput {
  terraform: BlueprintTerraformConfigurationInput
  manifest: BlueprintManifestConfigurationInput
  helm: BlueprintHelmConfigurationInput
}

input BlueprintConfigurationUpdate {
  terraform: BlueprintTerraformConfigurationUpdate
  helm: BlueprintHelmConfigurationUpdate
  kubernetesManifest: BlueprintManifestConfigurationUpdate
}

type BlueprintConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  nodes: [Blueprint!]!
}

enum BlueprintDriver {
  TERRAFORM
  KUBERNETES_MANIFEST
  HELM
}

enum BlueprintDriverAction {
  PLAN_DESTROY
  PLAN
  APPROVE
  APPLY
}

type BlueprintDriverActionExecution {
  id: UUID!
  driver: BlueprintDriver!
  action: BlueprintDriverAction!
  planExecution: BlueprintDriverActionExecution
  jobRun: JobRun
  approvedAt: Time
  createdAt: Time!
  updatedAt: Time!
}

type BlueprintDriverActionExecutionConnection {
  pageInfo: PageInfo!
  nodes: [BlueprintDriverActionExecution!]!
}

input BlueprintDriverActionInput {
  """- v0.ProjectV3ID"""
  projectID: UUID!
  driver: BlueprintDriver!
  action: BlueprintDriverAction!

  """
  Action-dependent input for the action execution
  
  Because GraphQL does not support Input Unions, this field cannot be statically type-checked.
  To document the structure for this field, we publish the input types in this schema.
  For example, if you are issuing the APPLY action to the TERRAFORM driver, look for TerraformPlanActionParameters.
  """
  parameters: Object
}

type BlueprintDriverActionResult {
  execution: BlueprintDriverActionExecution
}

"""
CAUTION: Experimental!

Provides a similar interface to the ProjectV3Workflow type.
"""
type BlueprintDriverWorkflow {
  id: UUID!
  status: ProjectV3WorkflowStatus!

  """
  The sequence of actions in the workflow. Useful for identifying the presence of a PROJECT_DELETE step.
  """
  stepActions: [BlueprintDriverWorkflowStepAction!]! @deprecated(reason: "this field is replaced by 'steps'")

  """
  The driver action execution records. NOTE: will not have a record for PROJECT_DELETE.
  """
  jobs: [BlueprintDriverActionExecution!] @deprecated(reason: "this field is replaced by 'steps'")
  steps: [BlueprintDriverWorkflowStep!]!
  createdAt: Time!
  updatedAt: Time!
}

input BlueprintDriverWorkflowInput {
  """The driver to execute the actions"""
  driver: BlueprintDriver!

  """
  The steps to execute. This list must not be empty, and must represent a valid workflow.
  
  - Plan-type actions must come first.
  - An Approval action must follow a Plan-type action.
  - An Apply action may follow a Plan-type or Approval action.
  - The "Project Delete" action must follow an Apply action, and the workflow must begin with the "Plan Destroy" action
  """
  steps: [BlueprintDriverWorkflowStepAction!]!
}

type BlueprintDriverWorkflowStep {
  action: BlueprintDriverWorkflowStepAction!
  status: BlueprintDriverWorkflowStepStatus!
  execution: BlueprintDriverActionExecution
}

enum BlueprintDriverWorkflowStepAction {
  DRIVER_PLAN_DESTROY
  DRIVER_PLAN
  DRIVER_APPROVE
  DRIVER_APPLY
  PROJECT_DELETE
}

enum BlueprintDriverWorkflowStepStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  ERROR
  ABORTED
}

type BlueprintHelmConfiguration {
  source: Source
}

input BlueprintHelmConfigurationInput {
  source: SourceInput
}

input BlueprintHelmConfigurationUpdate {
  source: SourceInput
}

type BlueprintManifestConfiguration {
  source: Source
  useKustomize: Boolean
  generator: KubernetesManifestGeneratorConfiguration
}

input BlueprintManifestConfigurationInput {
  source: SourceInput
  useKustomize: Boolean
}

input BlueprintManifestConfigurationUpdate {
  source: SourceInput
  useKustomize: Boolean
}

type BlueprintMetadata {
  id: UUID!
  slug: String!
  name: String!
  displayName: String!
  type: BlueprintType!
  description: String
  tags: [String!]!
  logoUrl: String
  metatags: [BlueprintMetadataMetaTag]
  version: String
  versions: [BlueprintMetadataVersion!]!
  availableVersions: [String!]!
  latestVersion: String
  applicationVersion: String
  organizationName: String
  organizationDisplayName: String
  createdAt: Time
  updatedAt: Time
}

type BlueprintMetadataConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  nodes: [BlueprintMetadata!]!
}

input BlueprintMetadataFilter {
  name: StringCriterion
}

type BlueprintMetadataMetaTag {
  name: String!
  value: String!
}

type BlueprintMetadataVersion {
  prerelease: Boolean
  version: String!
  timestamp: Time
}

enum BlueprintOutputDataSource {
  INPUT
  OUTPUT
  RESOURCE
}

input BlueprintOutputSchema {
  entries: [BlueprintOutputSchemaEntry!]
}

input BlueprintOutputSchemaEntry {
  id: UUID
  name: String
  displayName: String
  type: VariableType
  dataSource: BlueprintOutputDataSource
  dataPath: String
  transformations: [BlueprintOutputTransformationType!]
  transformationContext: BlueprintOutputTransformationContext
}

input BlueprintOutputTransformationContext {
  yaml: BlueprintOutputTransformationYamlContext
}

enum BlueprintOutputTransformationType {
  CLUSTER_IP
  YAML
  DECODE_BASE64
}

input BlueprintOutputTransformationYamlContext {
  path: String!
}

type BlueprintOwner implements ProfileOwner {
  login: Login!
  name: String!
  avatar: URL
}

type BlueprintsMarketplace {
  blueprints(page: PageInput): BlueprintConnection
  blueprint(owner: Login!, slug: String!): Blueprint
  blueprintMetadata(owner: Login, slug: String!, version: String): BlueprintMetadata
  blueprintMetadataList(filter: FilterInput!): BlueprintMetadataConnection
}

type BlueprintTerraformConfiguration {
  registrySource: String @deprecated(reason: "use moduleSource field instead")
  moduleVersionConstraint: String @deprecated(reason: "use moduleSource field instead")
  githubSource: String @deprecated(reason: "use moduleSource field instead")
  moduleSource: TerraformModuleSource
  outputConfiguration: TerraformOutputConfiguration
  terraformVersion: String
}

input BlueprintTerraformConfigurationInput {
  registrySource: String
  moduleVersionConstraint: String
  githubSource: String
  gitIntegration: GitSourceIntegrationInput
  moduleSource: TerraformModuleSourceInput
  outputConfiguration: TerraformOutputConfigurationInput
  terraformVersion: String
}

input BlueprintTerraformConfigurationUpdate {
  gitIntegration: GitSourceIntegrationInput
  registrySource: String
  moduleVersionConstraint: String
  githubSource: String
  moduleSource: TerraformModuleSourceInput
}

enum BlueprintType {
  TERRAFORM
  KUBERNETES_MANIFEST
  HELM
  ZEET_KUBERNETES
  ZEET_AWS_LAMBDA
  ZEET_GCP_CLOUD_RUN
}

union BlueprintVariable = BlueprintVariableString | BlueprintVariableBoolean | BlueprintVariableInt | BlueprintVariableFloat | BlueprintVariableJSON

type BlueprintVariableBoolean {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Boolean!
}

type BlueprintVariableFloat {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Float!
}

"""
A ProjectV3's BlueprintVariable represent key-value pairs: each a variable name and its value.
These variables can either reference a variable spec, as defined by the Blueprint, or they can be declared
as "custom variables" for the ProjectV3.

To reference a variable spec, specify either variableSpecID or the variableName that corresponds to a variable spec.

To declare a custom variable, specify the variableName and the variableType.
If there is a variableSpec with the same name, the variableType will be ignored, and the variableSpec will take precedence.

All BlueprintVariables must specify their value. The VariableValueInput is serialized as a string, and is parsed
server-side according to the variableType.
"""
input BlueprintVariableInput {
  """
  ID of the corresponding variable spec. Must be present if variableName is not specified.
  """
  variableSpecID: UUID

  """
  Name of the corresponding variable spec, or name to use when declaring a variable without referencing a variable spec.
  Must be present if variableSpecID is not specified.
  """
  variableName: String

  """
  The variable value. Always a string value, which will be parsed according to the variableType, determined either
  by the referenced variableSpec, or the provided variableType
  """
  value: VariableValueInput!

  """
  Type specification is required when variable is being declared without referencing a variable spec.
  """
  variableType: BlueprintVariableType
}

type BlueprintVariableInt {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: Int!
}

type BlueprintVariableJSON {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: JSON!
}

type BlueprintVariableSpec {
  id: UUID!
  name: String!
  type: BlueprintVariableType!
  required: Boolean!
}

input BlueprintVariableSpecInput {
  name: String!
  type: BlueprintVariableType!
  required: Boolean!
}

input BlueprintVariableSpecUpdate {
  id: UUID
  name: String!
  type: BlueprintVariableType!
  required: Boolean!
  remove: Boolean
}

type BlueprintVariableString {
  id: UUID!
  variableSpecID: UUID
  name: String!
  value: String!
}

enum BlueprintVariableType {
  STRING
  BOOLEAN
  INTEGER
  FLOAT
  JSON
}

input BooleanCriterion {
  value: Boolean!
}

input BranchInput {
  active: Boolean
}

type Build {
  id: UUID!
  state: BuildState!
  image: String
  version: String
  errorMessage: String
  logs: Logs
  metrics(name: String!): [Metric!]
  backend: String
  buildID: String
  createdAt: Time!
  updatedAt: Time!
}

input BuildLogsInput {
  deploymentID: ID!
  after: String
}

type BuildMethod {
  name: String!
  type: BuildType!
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  staticPath: String
  runCommand: String
  releaseCommand: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
}

type BuildStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
  build: Build
  buildTemplates: [BuildTemplate!]
}

enum BuildState {
  BUILD_STARTING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
}

enum BuildTarget {
  NULL_REGISTRY
  CLUSTER_REGISTRY
  CONTAINER_REGISTRY
}

input BuildTargetInput {
  buildTarget: BuildTarget!
  clusterID: UUID
}

type BuildTemplate {
  type: BuildTemplateType!
  output: String
}

enum BuildTemplateType {
  DOCKERFILE
}

enum BuildType {
  DOCKER
  BUILDPACKS
  PYTHON
  PYTHON_DJANGO
  NODE
  NODE_STATIC
  NODE_NEXTJS
  UBUNTU
  ELIXIR_PHOENIX
  GOLANG_MODULES
  HEROKUISH
}

input CancelJobInput {
  id: UUID!
}

enum CatalogProductStatus {
  CURRENT
  UPGRADE
  DOWNGRADE
}

type CatalogProductView {
  product: Product!
  description: String

  """
  Indicates if this is part of the current subscription, or represents an upgrade or downgrade over the current product.
  Null if no user is being queried.
  """
  status: CatalogProductStatus

  """Whether this product is available for self-service purchasing."""
  available: Boolean!
}

type CDN {
  id: UUID!
  provider: CDNProvider!
  domains: [CDNDomain!]
  state: String!
  origin: String
  endpoint: String
  certificate: Certificate
}

type CDNDomain {
  domain: String!
  certReady: Boolean
  routeReady: Boolean
  instruction: DNSRecord
}

enum CDNProvider {
  AWS_CLOUDFRONT
}

type Certificate {
  provider: CertificateProivder
  dnsNames: [String!]
  issuing: Boolean!
  ready: Boolean!
  challenges: [CertificateChallenge!]
  instructions: [DNSRecord!]
  createdAt: Time!
  updatedAt: Time!
}

type CertificateChallenge {
  dnsName: String!
  type: String!
  solver: String!
  wildcard: Boolean!
  statusReason: String!
  statusState: String!
}

enum CertificateProivder {
  CERT_MANAGER
  AWS_ACM
}

enum CertManagerChallengeType {
  dns01
  http01
}

input CheckPriceInput {
  teamId: UUID
  source: RepoSourceType
  installation: ID
  owner: String
  repo: String
  dockerImage: String
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  cpu: String
  gpu: String
  memory: String
  dedicated: Boolean
}

type CheckPriceOutput {
  total: PriceComponent!
  subTotal: PriceComponent!
  cpu: PriceComponent!
  memory: PriceComponent!
  gpu: PriceComponent!
  volumes: PriceComponent!
  bandwidth: PriceComponent!
  misc: PriceComponent!
  canBeFreeTier: Boolean!
}

input CheckProjectNameInput {
  name: String!
}

interface CISource {
  name: String!
  owner: String!
  url: URL!
  description: String
}

union CloudAccount = AWSAccount | GCPAccount | DOAccount | CoreWeaveAccount | LinodeAccount | VultrAccount | AzureAccount

enum CloudAccountState {
  WAITING
  SUCCESS
  ERROR
}

enum CloudProvider {
  UNKNOWN
  ZEET
  AWS
  AZURE
  GCP
  ALIBABA
  OCI
  IBM
  TENCENT
  DO
  COREWEAVE
  OVH
  LINODE
  VULTR
  SCALEWAY
}

type CloudQueryService {
  state: CloudQueryState!
  id: UUID!
}

enum CloudQueryState {
  READY
  ERROR
  CREATING
  DELETING
}

type CloudResource {
  resourceType: CloudResourceType!
  id: String!
  shared: Boolean!
  region: String!
}

enum CloudResourceType {
  Machine
  Disk
  LoadBalancer
  VPC
  Cluster
}

type CloudRuntime {
  cloud: CloudAccount
  region: String
  awsLambda: String
  awsFargate: String
  gcpCloudRun: String
  azureApp: String
}

type Cluster {
  id: UUID!
  name: String!
  region: String
  state: ClusterState!
  status: ClusterStatus
  private: Boolean!
  connected: Boolean
  cloudProvider: CloudProvider
  clusterProvider: ClusterProvider
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  doAccount: DOAccount
  cwAccount: CoreWeaveAccount
  linodeAccount: LinodeAccount
  cloudAccount: CloudAccount
  vultrAccount: VultrAccount
  azureAccount: AzureAccount
  namespace: String
  domain: String
  isExternal: Boolean
  isEjected: Boolean
  terraformProjectUrl: String
  ingressIP: String
  ingressDNS: String
  clusterIssuers: [String!]
  prometheus: Prometheus
  grafana: Grafana
  staticIPs: [String!]
  kubeconfig: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistry: ContainerRegistry
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  customDomains: [ClusterCustomDomain!]

  """All configured cluster add-ons, whether currently enabled or disabled"""
  addOns: [ClusterAddOn!]
  createdAt: Time!
  updatedAt: Time!
  stateBackend: TerraformStateBackend
  deployJob: JobRun
  destroyJob: JobRun
  serverVersion: String!
  supportsEphemeralContainer: Boolean!
  components: [ClusterComponent]
  network: Network
  machines: [Machine!]
}

type ClusterAddOn {
  slug: String!
  state: ClusterAddOnState!
  helmValues: YAML
}

enum ClusterAddOnState {
  ENABLED
  DISABLED
}

type ClusterComponent {
  type: ClusterComponentType!
  name: String!
  isInstalledByZeet: Boolean!
  exists: Boolean!
  status: ClusterComponentEjectedStatus!
  helmMetadata: HelmClusterComponentMetadata
  terraformMetadata: TerraformClusterComponentMetadata
  project: ProjectV3Adapter
}

enum ClusterComponentEjectedStatus {
  NOT_FOUND
  DETECTED
}

enum ClusterComponentType {
  HELM
  TERRAFORM
}

type ClusterCustomDomain {
  id: UUID!
  cluster: Cluster
  repo: Repo
  customDomain: CustomDomain
}

type ClusterDomains {
  id: ID!
  cluster: Cluster!
  domains: [CustomDomain!]
}

enum ClusterProvider {
  GENERIC
  EKS
  GKE
  DOKS
  COREWEAVE
  LKE
  VKE
}

enum ClusterState {
  PENDING
  PENDING_SETUP
  CREATING
  HEALTHY
  DELETING
  ERROR
  ERROR_DELETING
}

enum ClusterStatus {
  PENDING
  PENDING_SETUP
  CREATING
  HEALTHY
  DELETING
  ERROR
  ERROR_DELETING
  UNREACHABLE
}

type ComplexLogs {
  previous: [LogEntry!]
  current: [LogEntry!]
  expired: Boolean!
}

input ConnectUserToIamInput {
  userID: UUID!
  awsIamArn: String
  awsAccountId: String
}

"""
A sentinel value returned when we are not able to facilitate self-service for a desired action
"""
enum ContactUs {
  CONTACT_US @deprecated(reason: "Use BillingActionNotAllowed instead.")
}

type Container {
  id: UUID!
  status: ContainerStatus!
}

type ContainerRegistry {
  id: UUID!
  name: String!
  registry: String!
  username: String
  credentialProvider: ContainerRegistryCredentialProvider
}

enum ContainerRegistryCredentialProvider {
  DOCKER
  ECR
  GCR
  DOCR
}

type ContainerRegistrySource {
  registryID: UUID
  registryURL: URL
  repository: String!
  tag: String
}

input ContainerRegistrySourceInput {
  registryID: UUID
  registryURL: URL
  repository: String!
  tag: String
}

type ContainerResourcesSpec {
  cpu: Float
  memory: Float
  ephemeralStorage: Float
  accelerator: AcceleratorSpec
  spot: Boolean
}

input ContainerResourcesSpecInput {
  cpu: Float!
  memory: Float!
  ephemeralStorage: Float
  accelerator: AcceleratorSpecInput
  spot: Boolean
}

type ContainerSpec {
  cpu: Float
  memory: Float
  gpu: Float
}

type ContainerStatus {
  scheduled: Boolean!
  running: Boolean!
  ready: Boolean!
}

type CoreWeaveAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  namespace: String
  connected: Boolean
  clusters: [Cluster!]
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type Cost {
  service: String
  unblendedCostAmount: Float
  unblendedCostUnit: String
  periodStart: String
  periodEnd: String
}

input CostByServiceWhere {
  services: [String!]!
}

input CostUsageWhere {
  granularity: String!
  dimensionType1: String!
  dimensionType2: String!
  dimension2NotIn: [String!]!
  dimension1In: [String!]!
}

input CreateAPIKeyInput {
  userID: UUID!
  name: String!
}

input CreateBitbucketIntegrationInput {
  userID: UUID!
  name: String
  accessToken: String!
}

input CreateBlueprintInput {
  userID: UUID!
  slug: String!
  displayName: String!
  published: Boolean!
  type: BlueprintType!
  configuration: BlueprintConfigurationInput
  variables: [BlueprintVariableSpecInput!]!
  richInputSchema: JSON
  description: String
  tags: [String!]
  logoUrl: String
}

input CreateClusterInput {
  userID: UUID!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  azureAccountID: UUID
  coreweaveAccountID: UUID
  name: String!
  region: String!
  isExternal: Boolean
  gcpClusterCreationOptions: GcpClusterCreationOptions
}

input CreateDatabaseInput {
  userID: UUID!
  name: String!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: DatabaseDeployTargetInput!
  engine: DatabaseEngineType!
  version: String!
  options: DatabaseOptions
}

input CreateDatadogIntegrationInput {
  userID: UUID!
  apiKey: String!
}

input CreateEmailIntegrationInput {
  userID: UUID!
  emailAddress: String!
}

input CreateEphemeralContainerInput {
  image: String!
}

input CreateEventIntegrationInput {
  userID: UUID!
  eventType: EventIntegrationType!
  clusterID: UUID
}

input CreateGitlabIntegrationInput {
  userID: UUID!
  name: String
  apiUrl: URL
  accessToken: String!
}

input CreateIPFSServiceInput {
  userID: UUID!
  name: String!
  awsAccountID: UUID!
  clusterID: UUID!
}

input CreateManifestAppInput {
  userID: UUID!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  environmentName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  name: String!
  deployTarget: ProjectDeployInput!
  namespace: String
  githubConnection: GithubConnectionInput
  gitRepository: String
  manifests: [String!]
  manifestValue: String
}

input CreateProjectDockerInput {
  userID: UUID
  name: String

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  projectName: String
  environmentName: String
  deployTarget: ProjectDeployInput
  dockerImage: String!
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  ephemeralStorage: Float
  dedicated: Boolean
  gpu: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectEnvironmentInput {
  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID!
  name: String!
  repos: [UUID!]
}

input CreateProjectFromProjectTemplateInput {
  id: ID!
  deployTarget: ProjectDeployInput
  envs: [EnvVarInput!]
}

input CreateProjectGitInput {
  userID: UUID
  name: String

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  projectName: String
  environmentName: String
  url: String!
  productionBranch: String
  buildTarget: BuildTargetInput
  deployTarget: ProjectDeployInput
  build: ProjectBuildInput
  deployService: Boolean
  deployJob: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: [PortInput!]
  volumes: [VolumeInput!]
  replication: [ReplicationInput!]
  runCommand: String
  logShipper: LogShipperInput
  deployStrategy: DeployStrategy
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  clusterIssuerName: String
  hostNetwork: Boolean
  staticIP: Boolean
  nodeSelector: JSON
  noBuildCache: Boolean
  kanikoFlags: KanikoFlagsInput
  datadogApmEnabled: Boolean
  enabled: Boolean
  pipelineClusterID: UUID
  path: String
}

input CreateProjectHelmInput {
  userID: UUID!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  environmentName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  name: String!
  deployTarget: ProjectDeployInput!
  namespace: String
  releaseName: String!
  repository: String
  chart: String
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  values: String
  valuesRef: String
  enabled: Boolean
}

input CreateProjectInput {
  userID: UUID
  name: String

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  projectName: String
  environmentName: String
  installation: ID
  owner: String
  repo: String
  gitRepository: String
  githubConnection: GithubConnectionInput
  gitlabConnection: GitlabConnectionInput
  buildTarget: BuildTargetInput
  deployTarget: ProjectDeployInput
  productionBranch: String
  deployService: Boolean
  deployJob: Boolean
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployBranch: Boolean
  branchIgnore: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  envs: [EnvVarInput!]
  ports: JSON
  replication: [ReplicationInput!]
  volumes: JSON
  cpu: String
  memory: String
  dedicated: Boolean
  gpu: String
  buildCommand: String
  buildType: String
  runCommand: String
  staticPath: String
  enabled: Boolean
  teamID: ID
}

input CreateProjectsFromTemplateInput {
  id: ID!
  userID: UUID
  name: String
  projects: [CreateProjectFromProjectTemplateInput!]
}

input CreateProjectTerraformInput {
  userID: UUID!
  name: String!
  deployTarget: ProjectDeployInput!
  githubConnection: GithubConnectionInput
  gitRepository: String
  gitReference: String
  workingDirectory: String
  variables: JSON
  envs: [EnvVarInput!]
  terraformVersion: String
  manualApproval: Boolean
  enabled: Boolean
}

input CreateProjectV2Input {
  userID: UUID!
  name: String!
}

input CreateProjectV3Input {
  blueprintID: UUID!
  userID: UUID!
  name: String!
  requirePlanApproval: Boolean
  blueprintConfiguration: BlueprintConfigurationInput
  variables: [BlueprintVariableInput!]!
  terraformConfiguration: TerraformProjectV3ConfigurationInput
  manifestConfiguration: ManifestProjectV3ConfigurationInput
  helmConfiguration: HelmProjectV3ConfigurationInput
  awsSamConfiguration: AwsSamProjectV3ConfigurationInput
  gcpCloudRunConfiguration: GcpCloudRunProjectV3ConfigurationInput

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  projectName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  environmentName: String
  isDeployV2: Boolean
}

input CreateRepoPipelineLinkInput {
  sourceRepoID: UUID!
  sourceEvent: RepoEvent!
  targetRepoID: UUID
  targetEnvironmentID: UUID
  targetAction: RepoAction!
}

input CreateResourceAlphaInput {
  userID: UUID!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  projectName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  environmentName: String
  name: String!
  appID: String
  enabled: Boolean
  workflow: ResourceWorkflowInput
  branch: ResourceBranchInput
  source: SourceInput
  build: ResourceBuildInput
  kubernetes: ResourceKubernetesInput
  serverless: ResourceServerlessInput
  terraform: ResourceTerraformInput
  database: ResourceDatabaseInput
  blueprintID: UUID
}

input CreateTeamInput {
  name: String!
  login: String
  billingEmail: String!
  avatar: String
  paymentMethod: String
  tier: PlanTier
  billingPeriod: PlanBillingPeriod
}

input CreateWeb3ChallengeInput {
  address: String!
}

input CreateWebhookIntegrationInput {
  userID: UUID!
  url: String!
}

type CrispAuth {
  email: String!
  hmac: String!
  participants: String!
  nickname: String!
}

type CustomDomain {
  id: ID!
  domain: String!
  cnameTargets: [String!]
  ipTargets: [String!]
  isApex: Boolean!
  disableCertManager: Boolean
  certManagerChallengeType: CertManagerChallengeType
  syncDomain: CustomDomain
  instructions: [DNSRecord!]
  certificate: Certificate
}

input DatabaseDeployTargetInput {
  provider: DatabaseProviderType!
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  clusterID: UUID
  region: String
}

enum DatabaseEngineType {
  POSTGRES
  MYSQL
  MONGODB
  REDIS
  KAFKA
  NATS
}

type DatabaseLink {
  id: UUID!
  repo: Repo!
  database: Repo!
  envPrefix: String
  envs: [EnvVar!]
}

input DatabaseOptions {
  username: String
  password: String
  database: String
}

enum DatabaseProviderType {
  AWS_RDS
  GCP_CLOUD_SQL
  DO_DATABASE
  DOCKER
}

type DatadogIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiKey: String
}

type DatadogLogIntegration {
  key: String!
  host: String
}

input DatadogLogIntegrationInput {
  key: String!
  host: String
}

input DeployableDriverActionExecutionFilter {
  ids: MultiEntityCriterion
  actionTypes: DriverActionTypeCriterion
  resourceIds: MultiEntityCriterion
}

type Deployment {
  id: ID!
  description: String
  version: String!
  status: DeploymentStatus!
  endpoints: [String!]
  privateEndpoint: String
  loadBalancers: [LoadBalancer!]
  errorMessage: String

  """
  An optional structured error, containing more information than the simple 'errorMessage'
  """
  deploymentError: DeploymentError
  branch: String
  build: Build
  buildStage: BuildStage
  testStage: PipelineStage
  releaseStage: PipelineStage
  deployStage: PipelineStage
  deleteStage: PipelineStage
  deployTemplates: [DeployTemplate]
  logs: [LogEntry!]
  logsV2: ComplexLogs
  repo: Repo
  deployStatus: DeployStatus
  containers: [Container!]
  metrics(name: String!): [Metric!]
  volumes: [Volume!]
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  githubLinks: GithubLinks
  helmRelease: HelmRelease
  dataOut: String
  pipelineCluster: Cluster
  createdAt: Time!
  updatedAt: Time!
  release: Release
  deployStep: PipelineStep
  alternativeImages: [AlternativeImage!]
  ephemeralContainers: [EphemeralContainer]
  alert(id: UUID!): DeploymentAlert
  metricsV2(metricType: MetricType!, deploymentID: UUID!, queryOptions: MetricQueryOptions): [MetricStream!]

  """
  List the history of alerts for this deployment.
  
  The `page` input only supports `first`, and one of `before` or `after`. Default is 10 most recent alerts.
  """
  alerts(page: PageInput): DeploymentAlertConnection
  events: [Event!]!
  runtime: Runtime
  terraformOperation: TerraformOperation
}

interface DeploymentAlert {
  createdAt: Time!
  resolvedAt: Time
}

type DeploymentAlertConnection {
  nodes: [DeploymentAlert!]!
  pageInfo: PageInfo!
}

type DeploymentConnection {
  totalCount: Int!
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

type DeploymentError {
  message: String!
  errorID: String
  errorCode: String
}

type DeploymentPodCrashAlert implements DeploymentAlert {
  id: UUID!
  namespace: String
  podName: String
  previousPodLogs: Logs
  createdAt: Time!
  resolvedAt: Time
}

input DeploymentsInput {
  first: Int = 10
  after: String
  branch: String
}

enum DeploymentStatus {
  BUILD_PENDING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
  DEPLOY_PENDING
  DEPLOY_IN_PROGRESS
  RELEASE_IN_PROGRESS
  DEPLOY_FAILED
  DEPLOY_SUCCEEDED
  BUILD_ABORTED
  DEPLOY_STOPPED
  DEPLOY_HEALHTY
  DEPLOY_CRASHING
}

input DeployRepoBranchInput {
  id: UUID!
  branch: String!
}

enum DeployRuntime {
  AWS_LAMBDA
  AWS_ECS
  GCP_CLOUD_RUN
  KUBERNETES
  KNATIVE
}

type DeployStatus {
  active: Boolean!
  publicIPs: [String!]
  state: String!
  replicas: Int!
  runningReplicas: Int!
  readyReplicas: Int!
  errorMessage: String
  troubleshooting: Troubleshooting
}

enum DeployStrategy {
  RESTART
  ROLLING
  CANARY
  BLUE_GREEN
  RED_BLACK
}

enum DeployTarget {
  KUBERNETES
  SERVERLESS
  TERRAFORM
  PULUMI
  AWS_SAM
  AWS_CDK
  AWS_CLOUDFORMATION
  GCP_CLOUD_RUN
}

type DeployTemplate {
  type: DeployTemplateType!
  output: String
}

enum DeployTemplateType {
  YAML
}

enum DeployType {
  KUBERNETES
  KNATIVE
  HELM
  KUBECTL
  KUBERNETES_UNSTRUCTURED
}

input DetachAwsPolicyToUser {
  userID: UUID!
  policyArn: String!
  awsUsername: String!
  awsAccountCredentialsId: UUID!
}

enum DisableReason {
  FREE_TRIAL_ENDED
  USER_ACTION
  PAYMENT_ERROR
  USER_BANNED
}

type DiscordIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type DiscordWebhookIntegration implements Integration & NotificationIntegration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
  notificationSettings: NotificationIntegrationSettings
  deliveryError: NotificationDeliveryError
}

input dispatchRepoGroupActionInput {
  groupID: UUID
  selector: LabelSelectorsInput
  action: RepoActionInput!
}

type DNSRecord {
  name: String
  domain: String!
  type: DNSRecordType!
  value: String
}

enum DNSRecordType {
  A
  CNAME
  TXT
}

type DOAccount {
  id: UUID!
  name: String!
  state: DOAccountState!
  accessTokenPrefix: String
  accessToken: String
  defaultProject: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum DOAccountState {
  WAITING
  SUCCESS
  ERROR
}

type DockerImage {
  id: ID!
  tag: String!
  digest: String!
  repository: DockerRepository!
}

type DockerRepository implements CISource {
  id: ID!
  name: String!
  owner: String!
  url: URL!
  isPrivate: Boolean!
  description: String
  images: [DockerImage!]
  image(tag: String!): DockerImage
  ports: [Port!]
  volumes: [VolumeSpec!]
}

input DriverActionTypeCriterion {
  value: [BlueprintDriverAction]
  operator: FilterCriterionOperatorType
}

input DuplicateBlueprintInput {
  id: UUID!
  userID: UUID!
  name: String!
  slug: String!
  published: Boolean!
}

input DuplicateProjectInput {
  """- v0.RepoID"""
  id: UUID!
  enabled: Boolean!
  name: String!

  """
  Duplicate repo to existing project
  - v0.ProjectID or v1.GroupID
  """
  projectID: UUID

  """Creates a new environment by name"""
  environmentName: String

  """
  Put the new repo in an existing environment within the specified project
  - v0.EnvironmentID or v1.SubGroupID
  """
  environmentID: UUID
}

input DuplicateProjectV3Input {
  """- v0.ProjectV3ID"""
  id: UUID!
  name: String!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  projectName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  environmentName: String
}

scalar Duration

type EmailIntegration implements Integration & NotificationIntegration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  emailAddress: String!

  """
  An email integration must be confirmed by the recipient before it can be considered active.
  """
  activated: Boolean
  notificationSettings: NotificationIntegrationSettings
  deliveryError: NotificationDeliveryError
}

type EnvironmentOverview {
  deploymentStatus: DeploymentStatus
  count: Int
}

type EnvironmentOverviewV2 {
  deploymentStatus: ProjectV3AdapterStatus!
  count: Int!
}

type EnvVar {
  id: ID!
  name: String!
  value: String!
  visible: Boolean!
  sealed: Boolean!
  source: EnvVarSource
  createdAt: Time!
  updatedAt: Time!
}

input EnvVarInput {
  name: String!
  value: String!
  sealed: Boolean
}

type EnvVarSource {
  type: EnvVarSourceType!
}

enum EnvVarSourceType {
  ZEET
  PROJECT
  ENVIRONMENT
  CLUSTER
  DATABASE
  PROJECT_LINK
}

type EnvVarTemplate {
  name: String!
  description: String!
  value: String
  generator: String
  reference: String
  required: Boolean!
  locked: Boolean!
  hidden: Boolean!
  options: [String!]
}

type EphemeralContainer {
  name: String!
  image: String!
  ready: Boolean!
}

enum ErrorCode {
  CardDeclined
  NoContainers
  NeedAuth
  NeedPaymentDetails
  NoActiveBuildMethodError
  NoDockerfilePresent
  NoPortsExposed
  InternalServerError
}

type Event {
  id: String!
  type: EventType!
  message: String!
  source: String!
  count: Int!
  lastSeenAt: Time!
}

type EventIntegration {
  id: UUID!
  eventType: EventIntegrationType!
  integrationKey: String!
  integrationUrl: URL!
  clusterID: UUID
}

enum EventIntegrationType {
  SNS
}

enum EventType {
  INFO
  WARNING
  ERROR
}

type ExternalBillingProviderLinks {
  invoiceHistory: UrlOrContactUs!
  managePaymentMethod: UrlOrContactUs!
  downgrade: UrlOrContactUs!
  help: UrlOrContactUs!
}

enum FeatureKey {
  ADVANCED_AUTOSCALING
  DATADOG_APM
  STATIC_EGRESS
  SUPPORT_CENTER
}

input FilterCriterion {
  userFilter: UserFilter
  resourceFilter: ResourceFilter
  repoFilter: RepoFilter
  deployableDriverActionExecutionFilter: DeployableDriverActionExecutionFilter
  resourceAdapterFilter: ResourceAdapterFilter
  blueprintMetadataFilter: BlueprintMetadataFilter
}

enum FilterCriterionOperatorType {
  EQUALS
  NOT_EQUALS
  INCLUDES
  EXCLUDES
  STARTS
  ENDS
  CONTAINS
}

input FilterExpression {
  operator: FilterExpressionOperator
  filters: [FilterNode!]
}

enum FilterExpressionOperator {
  AND
  OR
  NOT
}

input FilterInput {
  sort: SortInput
  page: PageInput
  filter: FilterNode!
}

input FilterNode {
  expression: FilterExpression
  criterion: FilterCriterion
}

type GCPAccount {
  id: UUID!
  name: String!
  state: GCPAccountState!
  error: String
  connected: Boolean
  projectID: String
  clientEmail: String
  credentials: String
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

enum GCPAccountState {
  WAITING
  SUCCESS
  ERROR
}

type GcpCloudRunGeneratorConfiguration {
  envVars: [EnvVar!]
  name: String!
  httpPort: String
  containerMemory: Float
  containerCpu: Float
  runCommand: String
}

input GcpCloudRunGeneratorConfigurationInput {
  envVars: [EnvVarInput]
  name: String!
  httpPort: String
  containerMemory: Float
  containerCpu: Float
  runCommand: String
}

type GcpCloudRunProjectV3Configuration {
  gcpAccountId: UUID!
  gcpRegion: String
  generator: GcpCloudRunGeneratorConfiguration
}

input GcpCloudRunProjectV3ConfigurationInput {
  gcpAccountId: UUID!
  gcpRegion: String
  generator: GcpCloudRunGeneratorConfigurationInput
}

input GcpClusterCreationOptions {
  enableL4: Boolean!
  enableA100: Boolean!
}

type GCPLinks {
  deploymentManager: String
  cloudFunctions: String
  cloudFunctionsTrigger: String
  cloudRun: String
  cloudMonitoring: String
  cloudLogging: String
  gke: String
}

input GCSBucketBackendInput {
  gcpAccountID: UUID!
  location: String!
  bucketName: String!
  prefix: String
}

type GCSBucketConfiguration {
  gcpAccountID: UUID!
  location: String!
  bucketName: String!
  prefix: String
}

type GitBranch {
  id: ID!
  name: String!
  commit: GitCommit!
}

type GitCommit {
  id: ID!
  oid: String!
  abbreviatedOid: String!
  message: String!
  createdAt: Time!
}

type GithubCommitResult {
  processing: Boolean!
}

input GithubConnectionInput {
  apiUrl: URL
  installation: String!
  owner: String!
  repo: String!
}

type GitHubInstallation {
  id: ID!
  appID: Int!
  account: GitHubUser!
  repositorySelection: String!
  integrationType: GithubIntegrationType!
  targetType: String!
  repositories: [GitHubRepository!]
}

type GithubIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  login: String!
  appID: Int!
  installationID: Int!
  targetType: String!
}

enum GithubIntegrationType {
  User
  Team
}

type GithubLinks {
  commitURL: String
}

type GitHubRepoIntegration implements GitRepoIntegration {
  id: UUID!
  githubConnectionID: Int
  githubRepository: GitHubRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

input GitHubRepoIntegrationInput {
  githubConnectionID: Int
  githubOwner: String
  githubName: String
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  autoStopPullRequest: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

type GitHubRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
  buildMethodSuggestions: [BuildMethod!]
  serverless: ServerlessConfig
  ports: [Port!]
  volumes: [VolumeSpec!]
}

type GitHubUser {
  id: ID!
  login: String!
  avatar: URL
  type: GithubUserType!
}

enum GithubUserType {
  User
  Organization
}

input GitlabConnectionInput {
  gitlabIntegrationID: UUID!
  projectPath: String
}

type GitlabIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  apiUrl: URL!
  accessTokenPrefix: String
  webhookUrl: URL!
  webhookToken: String!
}

type GitlabRepoIntegration implements GitRepoIntegration {
  id: UUID!
  gitlabIntegration: GitlabIntegration
  gitlabRepository: GitlabRepository
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

input GitlabRepoIntegrationInput {
  gitlabConnection: GitlabConnectionInput
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  autoStopPullRequest: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

type GitlabRepository implements GitRepository & CISource {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

enum GitProvider {
  GITHUB
  GITLAB
  BITBUCKET
}

interface GitRepoIntegration {
  autoDeployBranch: Boolean!
  autoStopBranch: Boolean!
  autoStopPullRequest: Boolean!
  branchIgnore: String!
  branchStopIgnore: String!
}

interface GitRepository {
  id: ID!
  provider: GitProvider!
  providerID: ID!
  name: String!
  owner: String!
  url: URL!
  description: String
  defaultBranch: GitBranch
  branches: [GitBranch!]
  isFork: Boolean!
  isPrivate: Boolean!
  updatedAt: Time!
  primaryLanguage: String
}

type GitSource {
  repository: String!
  ref: String
  path: String
  integration: GitSourceIntegration
}

input GitSourceInput {
  repository: String!
  ref: String
  path: String
  integration: GitSourceIntegrationInput
}

type GitSourceIntegration {
  githubInstallationID: Int
  githubIntegrationID: UUID
  gitlabIntegrationID: UUID
  bitbucketIntegrationID: UUID
}

input GitSourceIntegrationInput {
  githubInstallationID: Int
  githubIntegrationID: UUID
  gitlabIntegrationID: UUID
  bitbucketIntegrationID: UUID
}

enum GitSubmodulesType {
  NONE
  RECURSIVE
}

input GPUInput {
  type: String
  count: Int!
}

type GPUSpec {
  type: String
  count: Int!
}

type Grafana {
  url: String!
  user: String
  password: String
}

type GroupedAwsCostItem {
  timePeriod: TimePeriod!
  groups: [AwsServiceCostItem!]!
}

type HelmChart {
  id: String!
  repository: HelmRepository!
  name: String
  normalized_name: String
  description: String
  logoImage: String
  stars: Int
  version: String
  app_version: String
  deprecated: Boolean
}

type HelmChartConnection {
  totalCount: Int!
  nodes: [HelmChart!]!
  pageInfo: PageInfo!
}

type HelmClusterComponentMetadata {
  values: String!
  namespace: String!
  releaseName: String!
  chartName: String!
  chartVersion: String!
  chartRepoGuess: String
}

type HelmProjectV3Configuration {
  clusterID: UUID!
  namespace: String
  releaseName: String!
  values: YAML
}

input HelmProjectV3ConfigurationInput {
  clusterID: UUID!
  namespace: String
  releaseName: String!
  values: YAML
}

type HelmRelease {
  id: String!
  chart: HelmChart!
  version: String!
}

type HelmRepository {
  id: String!
  url: String
  name: String
  organization_name: String
  chart(name: String!): HelmChart!
}

type HelmRepositorySource {
  repositoryURL: URL!
  chart: String!
  version: String
}

input HelmRepositorySourceInput {
  repositoryURL: URL!
  chart: String!
  version: String
}

type HTTPProbe {
  host: String
  port: String!
  path: String
}

interface Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

enum IntegrationType {
  SLACK
  SLACK_WEBHOOK
  DISCORD
  DISCORD_WEBHOOK
  DATADOG
  GITLAB
  GITHUB
  EMAIL
  BITBUCKET
}

input InviteTeamMemberInput {
  id: UUID!
  role: TeamMemberRole!
  email: String
  expiresAt: Time
}

type IPFSService {
  id: UUID!
  owner: User!
  state: IPFSServiceState!
  cluster: Cluster
  accessToken: String
  apiURL: String
  nodeURL: String
  api: Project
}

enum IPFSServiceState {
  CREATING
  HEALTHY
  DELETING
  ERROR
}

interface IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type JobRun {
  id: UUID!
  state: JobRunState!
  command: String!
  exitCode: Int
  logs: Logs
  metrics(name: String!): [Metric!]
  errorMessage: String
  createdAt: Time
  updatedAt: Time
  build: Build
  deployment: Deployment
}

type JobRunConnection {
  totalCount: Int!
  nodes: [JobRun!]!
  pageInfo: PageInfo!
}

enum JobRunState {
  JOB_RUN_STARTING
  JOB_RUN_RUNNING
  JOB_RUN_FAILED
  JOB_RUN_SUCCEEDED
  JOB_RUN_PENDING_APPROVAL
}

scalar JSON

type KanikoFlags {
  compressedCaching: Boolean
}

input KanikoFlagsInput {
  compressedCaching: Boolean
}

type KubernetesCustomization {
  nodeSelector: MapString
  hostNetwork: Boolean
  podSpecPatch: YAML
  ingressSpecPatch: YAML
  serviceAccountName: String
  podAnnotations: MapString
  serviceAnnotations: MapString
  ingressAnnotations: MapString
  clusterIssuerName: String
}

input KubernetesCustomizationInput {
  nodeSelector: JSON
  hostNetwork: Boolean
  podSpecPatch: YAML
  ingressSpecPatch: YAML
  podAnnotations: JSON
  serviceAnnotations: JSON
  ingressAnnotations: JSON
  clusterIssuerName: String
}

type KubernetesManifestGeneratorConfiguration {
  envVars: [EnvVar!]
  runCommand: String
  serverlessMemory: Int
  serverlessArch: String
  customDomainHost: String
  customDomainCertificateArn: String
  httpPort: String
  buildImage: String
}

input KubernetesManifestGeneratorConfigurationInput {
  envVars: [EnvVarInput!]
  runCommand: String
  serverlessMemory: Int
  serverlessArch: String
  customDomainHost: String
  customDomainCertificateArn: String
  httpPort: String
  buildImage: String
}

type KubernetesRuntime {
  cluster: Cluster
  region: String
}

type KubernetesSecretMount {
  secretName: String!
  mountPath: String!
  readOnly: Boolean!
}

input KubernetesSecretMountInput {
  secretName: String!
  mountPath: String!
}

enum LabelSelectorOperator {
  In
  NotIn
  Exists
  DoesNotExist
}

type LabelSelectorRequirement {
  key: String!
  operator: LabelSelectorOperator!
  values: [String!]
}

input LabelSelectorRequirementInput {
  key: String!
  operator: LabelSelectorOperator!
  values: [String!]
}

type LabelSelectors {
  matchLabels: MapString
  matchExpressions: [LabelSelectorRequirement!]
}

input LabelSelectorsInput {
  matchLabels: MapString
  matchExpressions: [LabelSelectorRequirementInput!]
}

input LinkCloudToClusterInput {
  cloudType: CloudProvider!
  cloudId: UUID!
  clusterID: UUID!
  cloudAZ: String
  cloudRegion: String
}

input LinkDatabaseInput {
  id: UUID!
  databaseID: UUID!
  envPrefix: String
}

type LinodeAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  accessTokenPrefix: String
  accessToken: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type LoadBalancer {
  name: String!
  dns: [String!]!
  ips: [String!]!
  ports: [Int!]
}

type LogDNAIntegration {
  key: String!
}

input LogDNAIntegrationInput {
  key: String!
}

type LogEntry {
  text: String!
  timestamp: Time
}

scalar Login

type Logs {
  id: ID!
  cursor: String
  completed: Boolean!
  expired: Boolean!
  entries: [LogEntry!]
}

type LogShipper {
  type: LogShipperType!
  logz: LogzIntegration
  syslog: SyslogIntegration
  logDNA: LogDNAIntegration
  datadog: DatadogLogIntegration
  betterstack: BetterStackIntegration
}

input LogShipperInput {
  type: LogShipperType
  logz: LogzIntegrationInput
  syslog: SyslogIntegrationInput
  logDNA: LogDNAIntegrationInput
  datadog: DatadogLogIntegrationInput
  betterstack: BetterStackIntegrationInput
}

enum LogShipperType {
  LOGZIO
  SYSLOG
  LOGDNA
  DATADOG
  BETTERSTACK
}

type LogzIntegration {
  token: String!
  url: String
}

input LogzIntegrationInput {
  token: String!
  url: String!
}

type Machine {
  id: ID!
  name: String!
  region: String!
  data: JSON
  network: Network
  cluster: Cluster
  projects(input: ProjectsInput): ProjectConnection
}

type Manifest {
  manifests: [String!]
  manifestValue: String
  kustomizeDirs: [String!]
}

type ManifestProjectV3Configuration {
  clusterID: UUID!
  namespace: String
}

input ManifestProjectV3ConfigurationInput {
  clusterID: UUID!
  namespace: String
  generator: KubernetesManifestGeneratorConfigurationInput
}

scalar Map

scalar MapString

type Metric {
  timestamp: Time!
  value: Float
}

type MetricAnnotation {
  type: MetricAnnotationType!
  direction: MetricAnnotationDirection!
  function: MetricAnnotationFunction
  label: String
  value: Float
}

enum MetricAnnotationDirection {
  VERTICAL
  HORIZONTAL
}

enum MetricAnnotationFunction {
  AVERAGE
  MAX
  MIN
}

enum MetricAnnotationType {
  LINE
  POINT
}

type MetricEntry {
  timestamp: Time!
  value: Float
}

enum MetricLabelType {
  POD
  CONTAINER
}

input MetricQueryOptions {
  range: ObservabilityRange!
  groupBy: [MetricLabelType!]
}

type MetricStream {
  type: MetricType
  query: String!
  entries: [MetricEntry!]
  labels: [MetricStreamLabel!]
  annotations: [MetricAnnotation!]
}

type MetricStreamLabel {
  label: MetricLabelType!
  value: String!
}

enum MetricType {
  QUERY
  CPU
  MEMORY
  NETWORK
  STORAGE
  FUNCTION_INVOCATION
  FUNCTION_ERROR
  FUNCTION_DURATION
  FUNCTION_CONCURRENT
  REQUEST_COUNT
  INSTANCE_COUNT
  CPU_UTILIZATION
  MEMORY_UTILIZATION
}

input MoveRepoInput {
  id: UUID!

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID
  environmentName: String

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID
  name: String
}

input MultiEntityCriterion {
  value: [UUID!]
}

type Mutation {
  enableRepo(id: ID!): Repo!
  disableRepo(id: ID!): Repo!
  deleteRepo(id: ID!): Boolean!
  unlinkRepo(id: ID!): Boolean!
  buildRepo(id: ID!, branch: String, noCache: Boolean): Repo!
  abortBuild(id: UUID!): Repo!
  deployRepo(id: ID!): Repo!
  deployRepoBranch(input: DeployRepoBranchInput!): Repo!
  setRepoEnvs(input: SetRepoEnvsInput!): Repo!
  setPaymentMethod(paymentMethod: String!): User!
  copyEnvVars(from: ID!, to: ID!): Repo
  addProjectCollaborator(input: AddProjectCollaboratorInput!): Repo!
  removeProjectCollaborator(id: ID!): Repo!
  transferProject(input: TransferProjectInput!): Repo!
  createAPIKey(input: CreateAPIKeyInput): APIKey!
  deleteAPIKey(id: UUID!): Boolean!
  addAWSAccount(input: AddAWSAccountInput!): AWSAccount!
  verifyAWSAccount(id: UUID!): AWSAccount!
  removeAWSAccount(id: UUID!): Boolean!
  updateAWSAccount(input: UpdateAWSAccountInput!): Boolean!
  connectUserToIam(input: ConnectUserToIamInput!): Boolean!
  disconnectUserFromIam(id: UUID!): Boolean!
  attachAwsPolicyToUser(input: AttachAwsPolicyToUser!): Boolean!
  detachAwsPolicyToUser(input: DetachAwsPolicyToUser!): Boolean!
  checkAwsRegionConnection(awsAccountID: UUID!, region: String!): AwsRegionStatus!
  addAzureAccount(input: AddAzureAccountInput!): AzureAccount!
  updateAzureAccount(input: UpdateAzureAccountInput!): Boolean!
  removeAzureAccount(id: UUID!): Boolean!

  """
  Modify the user's subscription using the subscriptionCart, and initiate
  recurring billing for the user's payment method on file.
  """
  purchaseSubscription(forUserID: UUID!, subscriptionCart: SubscriptionCart!): SubscriptionPurchaseResponse!
  createBitbucketIntegration(input: CreateBitbucketIntegrationInput!): BitbucketIntegration!
  updateBitbucketIntegration(input: UpdateBitbucketIntegrationInput!): BitbucketIntegration!
  updateBranch(input: UpdateBranchInput!): RepoBranchV2!
  addCDN(input: AddCDNInput!): CDN!
  updateCDN(input: UpdateCDNInput!): CDN!
  removeCDN(id: UUID!): Boolean!
  invalidateCDNCache(id: UUID!): CDN!
  ensureCloudqueryEnabled(awsAccountId: UUID!): Boolean!
  createCluster(input: CreateClusterInput!): Cluster!
  deleteCluster(id: UUID!): Boolean!
  unlinkCluster(id: UUID!): Boolean!
  updateCluster(input: UpdateClusterInput!): Cluster!
  addCluster(input: AddClusterInput!): Cluster!
  linkCloudToCluster(input: LinkCloudToClusterInput!): Cluster!
  updateClusterDomain(input: UpdateClusterDomainInput!): Cluster!
  addContainerRegistry(input: AddContainerRegistryInput!): ContainerRegistry!
  removeContainerRegistry(id: UUID!): Boolean!
  addCoreWeaveAccount(input: AddCoreWeaveAccountInput!): CoreWeaveAccount!
  updateCoreWeaveAccount(input: UpdateCoreWeaveAccountInput!): Boolean!
  removeCoreWeaveAccount(id: UUID!): Boolean!
  createDatabase(input: CreateDatabaseInput): Repo!
  linkDatabase(input: LinkDatabaseInput!): Repo!
  unlinkDatabase(id: UUID!): Boolean
  updateDatabaseLink(input: updateDatabaseLinkInput!): Repo!
  createBlueprint(input: CreateBlueprintInput!): Blueprint!
  updateBlueprint(blueprintID: UUID!, input: UpdateBlueprintInput!): Blueprint!
  duplicateBlueprint(input: DuplicateBlueprintInput!): Blueprint!
  deleteBlueprint(id: UUID!): Boolean!
  updateMarketplaceBlueprint(input: UpdateMarketplaceBlueprintInput!): Blueprint!
  maybeCreateBlueprintFromMetadata(slug: String!, version: String!): Blueprint!
  createProjectV3(input: CreateProjectV3Input!): ProjectV3!
  duplicateProjectV3(input: DuplicateProjectV3Input!): ProjectV3!

  """- projectID: v0.ProjectV3ID"""
  updateProjectV3(projectID: UUID!, input: UpdateProjectV3Input!): ProjectV3!

  """- id: v0.ProjectV3ID"""
  deleteProjectV3(id: UUID!): Boolean!

  """
  Converts an existing Zeet Repo into a Blueprint-based project. Only supports some repo types.
  """
  migrateRepoToProjectV3(repoID: UUID!): ProjectV3!
  configureGitopsForProjectV3(input: ProjectV3GitopsInput!): ProjectV3!

  """- projectID: v0.ProjectV3ID"""
  commitProjectV3ToGithubRepo(projectID: UUID!): GithubCommitResult!

  """
  DEPRECATED: use 'submitBlueprintDriverWorkflow' instead"
  @deprecated(reason: "single-action execution for blueprint drivers is replaced
  by driver workflows. use the 'submitBlueprintDriverWorkflow' mutation instead")
  """
  executeBlueprintDriverAction(input: BlueprintDriverActionInput!): BlueprintDriverActionResult!

  """
  CAUTION: Experimental!
  
  Submits a driver workflow to the workflow queue.
  Driver workflows are immutable: steps cannot be added after a workflow has been submitted.
  - projectID: v0.ProjectV3ID
  """
  submitBlueprintDriverWorkflow(projectID: UUID!, input: BlueprintDriverWorkflowInput!): BlueprintDriverWorkflow @deprecated(reason: "use the new 'submitWorkflow' from v1 api")
  approveBlueprintDriverWorkflow(workflowID: UUID!): BlueprintDriverWorkflow
  abortBlueprintDriverWorkflow(workflowID: UUID!): UUID
  createEphemeralContainer(deploymentId: UUID!, input: CreateEphemeralContainerInput!): EphemeralContainer!
  generateDownloadableLogLink(deploymentID: UUID!): String!
  addDOAccount(input: AddDOAccountInput!): DOAccount!
  updateDOAccount(input: UpdateDOAccountInput!): Boolean!
  removeDOAccount(id: UUID!): Boolean!
  addRepoCustomDomain(input: AddRepoCustomDomainInput!): Repo!
  removeRepoCustomDomain(input: RemoveRepoCustomDomainInput!): Repo!
  updateRepoCustomDomain(input: UpdateRepoCustomDomainInput!): Repo!
  reissueCustomDomainCertificate(input: ReissueCustomDomainCertificateInput!): Repo!
  createEventIntegration(input: CreateEventIntegrationInput!): EventIntegration!
  addGCPAccount(input: AddGCPAccountInput!): GCPAccount!
  updateGCPAccount(input: UpdateGCPAccountInput!): Boolean!
  removeGCPAccount(id: UUID!): Boolean!
  createGitlabIntegration(input: CreateGitlabIntegrationInput!): GitlabIntegration!
  updateGitlabIntegration(input: UpdateGitlabIntegrationInput!): GitlabIntegration!
  createProjectHelm(input: CreateProjectHelmInput): Repo!
  createSlackWebhookIntegration(input: CreateWebhookIntegrationInput!): SlackWebhookIntegration!

  """Always creates a new slack webhook integration."""
  createSlackWebhookIntegrationV2(input: CreateWebhookIntegrationInput!): SlackWebhookIntegration!
  updateSlackWebhookIntegration(input: UpdateWebhookIntegrationInput!): SlackWebhookIntegration!
  createDiscordWebhookIntegration(input: CreateWebhookIntegrationInput!): DiscordWebhookIntegration!

  """Always creates a new discord webhook integration."""
  createDiscordWebhookIntegrationV2(input: CreateWebhookIntegrationInput!): DiscordWebhookIntegration!
  updateDiscordWebhookIntegration(input: UpdateWebhookIntegrationInput!): DiscordWebhookIntegration!
  createDatadogIntegration(input: CreateDatadogIntegrationInput!): DatadogIntegration!
  createEmailIntegration(input: CreateEmailIntegrationInput!): EmailIntegration!
  removeUserIntegration(input: RemoveUserIntegrationInput!): Boolean!

  """
  Updates notification settings, in two ways:
  1. when integrationID is NOT specified: configures global settings for the user
  OR
  2. when integrationID IS specified: configures per-integration settings
  """
  updateNotificationIntegrationSettings(userID: UUID!, integrationID: UUID, input: NotificationIntegrationSettingsInput!): NotificationIntegrationSettings
  acknowledgeNotificationDeliveryError(userID: UUID!, integrationID: UUID!): NotificationDeliveryError
  createIPFSService(input: CreateIPFSServiceInput!): IPFSService!
  runJob(input: RunJobInput!): JobRun!
  cancelJob(input: CancelJobInput!): JobRun!
  addLinodeAccount(input: AddLinodeAccountInput!): LinodeAccount!
  updateLinodeAccount(input: UpdateLinodeAccountInput!): Boolean!
  removeLinodeAccount(id: UUID!): Boolean!
  createManifestApp(input: CreateManifestAppInput): Repo!
  createProjectV2(input: CreateProjectV2Input!): Project!
  updateProjectV2(input: UpdateProjectV2Input!): Project!
  deleteProjectV2(id: UUID!): Boolean!
  createProjectEnvironment(input: CreateProjectEnvironmentInput!): ProjectEnvironment!
  updateProjectEnvironment(input: UpdateProjectEnvironmentInput!): ProjectEnvironment!
  deleteProjectEnvironment(id: UUID!): Boolean!
  moveRepoToProjectEnvironment(input: MoveRepoInput!): Repo!
  dispatchRepoGroupAction(input: dispatchRepoGroupActionInput!): Boolean

  """
  Create a copy of a repo, optionally specifying the target project and project environment
  """
  duplicateProject(input: DuplicateProjectInput!): Repo!

  """- id: v0.RepoID"""
  deleteProjectBranch(id: UUID!, branch: String!): Boolean!

  """- projectID: v0.RepoID"""
  rollbackProjectToDeployment(projectID: UUID!, deploymentID: UUID!): Repo!
  updateProject(input: UpdateProjectInput!): Repo!
  updateProjectDanger(input: UpdateProjectDangerInput!): Repo!
  removeProbe(input: RemoveProbeInput!): Repo!

  """- id: v0.RepoID"""
  removeLogShipper(id: UUID!): Boolean!

  """- id: v0.RepoID"""
  migrateGithubConnection(id: UUID!, installationID: String!): Repo!
  createProject(input: CreateProjectInput): Repo!
  createProjectDocker(input: CreateProjectDockerInput): Repo!
  createProjectGit(input: CreateProjectGitInput): Repo!
  createResourceAlpha(input: CreateResourceAlphaInput!): Repo!
  updateResourceAlpha(repoID: UUID!, input: UpdateResourceAlphaInput!): Repo!
  createRepoPipelineLink(input: CreateRepoPipelineLinkInput!): RepoPipelineLink!
  updateRepoPipelineLink(input: UpdateRepoPipelineLinkInput!): RepoPipelineLink!
  deleteRepoPipelineLink(id: UUID!): Boolean
  createTeam(input: CreateTeamInput!): Team!
  deleteTeam(id: UUID!): Boolean!
  updateTeam(input: UpdateTeamInput!): Team!
  updateTeamMemberRole(input: UpdateTeamMemberRoleInput!): UserTeamEdge!
  addTeamMember(input: AddTeamMemberInput!): Team!
  removeTeamMember(input: RemoveTeamMemberInput!): Team!
  inviteTeamMember(input: InviteTeamMemberInput!): TeamMemberInvitation!
  acceptTeamMemberInvitation(token: String!): Team!
  resendTeamMemberInvitation(id: UUID!): Boolean!
  deleteTeamMemberInvitation(id: UUID!): Boolean!
  uploadDockerCompose(contents: String!): Template!
  createProjectsFromTemplate(input: CreateProjectsFromTemplateInput!): [Repo!]!
  freezeRepo(id: UUID!): Template!
  createProjectTerraform(input: CreateProjectTerraformInput): Repo!
  updateUser(input: UpdateUserInput!): User!
  deleteUser: Boolean!
  addVultrAccount(input: AddVultrAccountInput!): VultrAccount!
  updateVultrAccount(input: UpdateVultrAccountInput!): Boolean!
  removeVultrAccount(id: UUID!): Boolean!
  createWeb3Challenge(input: CreateWeb3ChallengeInput!): Web3Challenge!
  signInWithWeb3(input: SignInWithWeb3Input!): UserAuth!
}

type Network {
  id: ID!
  name: String!
  region: String!
  data: JSON
  cloud: CloudAccount
  clusters: [Cluster!]
  machines: [Machine]
}

"""
A notification condition represents a test of some attribute against a target value. A NotificationCondition is evaluated
to a true/false value, and can be combined via  NotificationConditionGroup.

For example: {operator: EQUALS, key: PROJECT_ID, value: "abc-123"} will test a
given notification for `event.project_id == "abc-123"`
"""
type NotificationCondition {
  """The method by which the key is tested relative to the target value"""
  operator: NotificationConditionOperator

  """The key to test using the operator and value"""
  key: NotificationConditionKey

  """
  The required value to satisfy the operator against the specific key.
  The type of this will depend on the key and the operator, for example: {operator: EQUALS, key: PROJECT_ID}
  will expect a string value.
  
  For example, if the IN operator is used with the PROJECT_ID key, the value will be a a json array: ["abc-123", "def-456"]
  """
  value: JSON
}

"""Represents the logical combination of one or more conditions"""
type NotificationConditionGroup {
  """The operator used to combine the conditions"""
  operator: NotificationConditionGroupOperator

  """
  The child conditions and/or condition groups to be evaluated using the specified operator.
  WARNING: Only 1 NotificationCondition is currently supported
  """
  conditions: [NotificationConditionProvider!]!
}

input NotificationConditionGroupInput {
  operator: NotificationConditionGroupOperator!
  conditions: [NotificationConditionInput!]!
}

enum NotificationConditionGroupOperator {
  """
  The condition group is satisfied when ALL child conditions are satisfied
  """
  ALL

  """
  The condition group is satisfied when ANY of the child conditions are satisfied.
  WARNING: Not yet supported
  """
  ANY
}

input NotificationConditionInput {
  operator: NotificationConditionOperator!
  key: NotificationConditionKey!
  value: JSON!
}

"""The set of available condition keys"""
enum NotificationConditionKey {
  """
  This is the id of the project (called a 'Group' in v1 API) which the notification originated from.
  """
  PROJECT_ID

  """
  This is the id of the project environment (called a 'SubGroup' in v1) which the notification originated from.
  """
  PROJECT_ENVIRONMENT_ID

  """
  This is the id of the ProjectV3Adapter ('Project' in v1 API) which the notification originated from.
  """
  PROJECT_V3_ADAPTER_ID
}

enum NotificationConditionOperator {
  """The equality (==) operator, i.e. <key> == <value>"""
  EQUALS
}

"""
Conditions can be provided as either a singular condition or a group of combined conditions.
When a notification is triggered by Zeet, a NotificationConditionProvider, if
configured, will be evaluated against the notification's attributes.
If the NotificationConditionProvider is satisfied (i.e. evaluates to 'true'),
then the notification will be forwarded to the target integration.
"""
union NotificationConditionProvider = NotificationCondition | NotificationConditionGroup

"""
The definition for notification conditions or notification.

An instance of this input type can represent one of the following:
- a single condition group: the 'groups' list is not empty, and the operator is not present
- a combination of condition groups: the 'groups' list contains multiple members, and the operator is present
- a single condition: the 'condition' field is present
- clearing any configured conditions: the noConditions field is present and set to true
"""
input NotificationConditionProviderInput {
  operator: NotificationConditionGroupOperator
  groups: [NotificationConditionGroupInput!]
  condition: NotificationConditionInput
  noConditions: Boolean
}

type NotificationDeliveryError {
  message: String!
  errorID: String
  errorCode: String

  """
  A user may "acknowledge" this delivery error, which will set this timestamp.
  """
  acknowledgedAt: Time
}

"""A destination for Zeet notifications."""
interface NotificationIntegration {
  """
  A notification integration can independently configure notification settings.
  When null, this integration will use the user's
  notificationIntegrationSettings.
  
  NOTE: These settings are NOT individually "merged" with the user's
  notificationIntegrationSettings, either the integration's settings are used,
  or the user's settings are used as a fallback.
  """
  notificationSettings: NotificationIntegrationSettings

  """
  The latest error that prevented delivery of a notification via this integration.
  """
  deliveryError: NotificationDeliveryError
}

type NotificationIntegrationSettings {
  """Enable/Disable build notifications"""
  build: Boolean

  """Enable/Disable deploy notifications"""
  deploy: Boolean

  """Enable/Disable kubernetes pod crash notifications"""
  podCrash: Boolean

  """
  The condition that must be satisfied for a notification to be forwarded to this integration.
  A null value indicates all configured notifications will be forwarded.
  
  Conditions apply to _all_ configured notification types. To apply different
  conditions independently to each notification type,
  create a separate notification integration for each notification type, and apply the desired conditions to each.
  
  NOTE: Conditions cannot be configured "globally" for a user.
  """
  conditions: NotificationConditionProvider
}

input NotificationIntegrationSettingsInput {
  """
  Enable/Disable build notifications, null causes no change to current setting
  
  NOTE: not applicable to "global" settings, only applicable to integration-specific settings
  """
  build: Boolean

  """
  Enable/Disable deploy notifications, null causes no change to current setting
  
  NOTE: not applicable to "global" settings, only applicable to integration-specific settings
  """
  deploy: Boolean

  """
  Enable/Disable kubernetes pod crash notifications, null causes no change to current setting
  """
  podCrash: Boolean

  """
  NOTE: Conditions cannot be configured "globally" for a user. Conditions may only be configured for a specific integration.
  """
  conditions: NotificationConditionProviderInput
}

scalar Object

input ObservabilityRange {
  start: Time!
  end: Time
  step: Duration
}

type PageInfo {
  startCursor: String!
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

input PageInput {
  first: Int = 10
  last: Int
  after: String
  before: String
  filter: String
  sort: String
}

scalar PermissibleMutation

type PipelineStage implements IPipelineStage {
  id: UUID!
  logs: Logs
  metrics(name: String!): [Metric!]
  job: JobRun
}

type PipelineStep {
  id: UUID!
  logs: Logs
}

type Plan {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod
  stripeSubscription: StripeSubscription
}

enum PlanBillingPeriod {
  MONTHLY
  ANNUALLY
}

enum PlanTier {
  LEGACY @deprecated(reason: "LEGACY plan tier is no longer supported")
  BASIC
  PRO
}

type PlanTierV2 implements Product {
  name: String
  description: String
  sku: ID!
  displayPrice: String
  usage: [Usage!]!
  benefits: [String!]!
  productTypeMetadata: ProductTypeMetadata
}

type Port {
  port: String!
  protocol: String!
  public: Boolean!
  https: Boolean!
  grpc: Boolean!
  loadBalancer: Boolean!
}

input PortInput {
  port: String!
  protocol: PortProtocol!
  public: Boolean!
  https: Boolean!
  grpc: Boolean
}

enum PortProtocol {
  tcp
  udp
}

type PriceComponent {
  cost: Int!
  explanation: String!
}

type Prices {
  ramGB: Float!
  cpuCore: Float!
  dedicatedGPU: Float!
  dedicatedRamGB: Float!
  dedicatedCpuCore: Float!
  storageGB: Float!
}

type Probe {
  command: String
  http: HTTPProbe
  tcp: TCPProbe
  initialDelaySeconds: Int!
  periodSeconds: Int!
  successThreshold: Int!
  failureThreshold: Int!
  timeoutSeconds: Int!
}

input ProbeInput {
  command: String
  httpEndpoint: String
  tcpEndpoint: String
  initialDelaySeconds: Int
  periodSeconds: Int
  successThreshold: Int
  failureThreshold: Int
  timeoutSeconds: Int
}

interface Product {
  productTypeMetadata: ProductTypeMetadata
  name: String
  description: String

  """
  A string used to communicate the price of this product. No currency or format should be assumed.
  """
  displayPrice: String
  sku: ID!

  """Any usage governed by this Product."""
  usage: [Usage!]!

  """Any benefit descriptions."""
  benefits: [String!]!
}

type ProductCatalog {
  """
  Shows all available products in the catalog. When no user is specified, it shows all available products.
  When a user is specified, the response can be enriched with information from their current subscription (if one exists).
  """
  products(forUserID: UUID): [ProductCatalogSection!]!

  """
  Returns a preview of the new invoice that would result from modifying the
  user's existing subscription based on the subscriptionCart.
  
  This query should be checked before attempting purchaseSubscription with the same cart.
  """
  previewSubscription(forUserID: UUID!, subscriptionCart: SubscriptionCart!): SubscriptionPurchasePreview!
}

"""
A section of the product catalog, showing products of a single type (Plan Tier, Support Tier, etc)
"""
type ProductCatalogSection {
  sectionName: String!

  """Metadata for the product type this section is for"""
  productTypeMetadata: ProductTypeMetadata

  """All available products, regardless of the current subscription."""
  allProducts: [CatalogProductView!]!
}

type ProductPurchasePreview {
  """
  The section name that the products in this preview would appear under in the product catalog.
  """
  sectionName: String!

  """Metadata for the product type of the two products in this preview."""
  productTypeMetadata: ProductTypeMetadata

  """
  The current product on the subscription that is possibly being replaced by newProduct.
  """
  currentProduct: Product

  """
  The product that will replace currentProduct, or currentProduct if no change is being made.
  """
  newProduct: Product

  """
  The status of newProduct relative to the currentProduct (i.e. downgrade/no change/upgrade)
  """
  newProductStatus: CatalogProductStatus
}

enum ProductType {
  PLAN_TIER
  PROJECT_PACK
  SUPPORT_TIER
  API_ACCESS
}

type ProductTypeMetadata {
  productType: ProductType
  displayName: String
  pricingPageAnchor: String
}

interface ProfileOwner {
  login: Login!
  name: String!
  avatar: URL
}

type Project {
  """- v0.ProjectID or v1.GroupID"""
  id: UUID!
  name: String!
  envs: [EnvVar!]
  isMultiRepo: Boolean!
  defaultEnvironment: ProjectEnvironment!

  """- id: v0.EnvironmentID or v1.SubGroupID"""
  environment(id: UUID, name: String): ProjectEnvironment!
  environments: [ProjectEnvironment!]!
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  owner: User!
  active: Boolean!
  revisions(page: PageInput): ProjectRevisionConnection
  createdAt: Time!
  updatedAt: Time!
}

input ProjectBuildInput {
  buildType: BuildType
  dockerfilePath: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
}

type ProjectCollaborator {
  id: ID!
  user: User!
  role: ProjectCollaboratorRole!
}

type ProjectCollaboratorInvitation {
  id: ID!
  email: String!
  link: String!
  role: ProjectCollaboratorRole!
  project: Repo!
}

enum ProjectCollaboratorRole {
  OWNER
  EDITOR
  VIEWER
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge!]!
  nodes: [Project!]!
}

input ProjectConnector {
  type: ProjectConnectorType
  fields: [ProjectConnectorField!]
}

input ProjectConnectorField {
  name: String
  displayName: String
  type: VariableType
  value: String
}

input ProjectConnectorSchema {
  entries: [ProjectConnectorSchemaEntry!]
}

input ProjectConnectorSchemaEntry {
  type: ProjectConnectorType
  fields: [ProjectConnectorSchemaField!]
}

input ProjectConnectorSchemaField {
  name: String
  displayName: String
  type: ProjectConnectorSchemaFieldType
}

enum ProjectConnectorSchemaFieldType {
  OUTPUT
}

enum ProjectConnectorType {
  DATABASE_CONNECTION
}

input ProjectDeployInput {
  deployTarget: DeployTarget!
  deployType: DeployType
  deployRuntime: DeployRuntime
  awsAccountID: UUID
  gcpAccountID: UUID
  doAccountID: UUID
  linodeAccountID: UUID
  vultrAccountID: UUID
  clusterID: UUID
  region: String
}

type ProjectEdge {
  cursor: String!
  node: Project!
}

type ProjectEnvironment {
  """- v0.EnvironmentID or v1.SubGroupID"""
  id: UUID!
  name: String!
  envs: [EnvVar!]
  defaultRepo: Repo
  repo(id: UUID, name: String): Repo
  repos: [Repo!]!
  repoConnection(page: PageInput, repoFilter: repoFilterInput): RepoConnection!
  overview: [EnvironmentOverview]
  overviewV2: [EnvironmentOverviewV2]
  projectV3Adapters: ProjectV3AdapterConnection
  revisions(page: PageInput): ProjectEnvironmentRevisionConnection
  project: Project
  createdAt: Time!
  updatedAt: Time!
}

type ProjectEnvironmentRevision implements RevisableEntity {
  revisionData: JSON!
  revisionMetadata: RevisionMetadata!
}

type ProjectEnvironmentRevisionConnection implements RevisionConnection {
  totalCount: Int!
  nodes: [ProjectEnvironmentRevision!]!
  pageInfo: PageInfo!
}

interface ProjectOwner {
  projects(input: ProjectsInput): ProjectConnection!
}

type ProjectPack implements Product {
  name: String
  description: String
  sku: ID!
  displayPrice: String
  usage: [Usage!]!
  benefits: [String!]!
  productTypeMetadata: ProductTypeMetadata
}

type ProjectRevision implements RevisableEntity {
  revisionData: JSON!
  revisionMetadata: RevisionMetadata!
}

type ProjectRevisionConnection implements RevisionConnection {
  totalCount: Int!
  nodes: [ProjectRevision!]!
  pageInfo: PageInfo!
}

input ProjectsInput {
  page: PageInput

  """
  When not null, will filter for projects that are active (true) or paused (false).
  """
  active: Boolean
}

type ProjectTemplate {
  id: ID!
  name: String!
  description: String!
  image: String!
  source: RepoSource!
  cpu: Float!
  memory: Float!
  envs: [EnvVarTemplate!]
  ports: [Port!]
  replication: [Replication!]
  volumes: [VolumeSpec!]
  gpu: Int
  dedicated: Boolean
}

type ProjectV3 {
  """- v0.ProjectV3ID"""
  id: UUID!
  name: String!
  blueprintID: UUID!
  blueprint: Blueprint
  requirePlanApproval: Boolean!
  variables: [BlueprintVariable!]!
  project: Project
  projectEnvironment: ProjectEnvironment
  configuration: ProjectV3Configuration

  """The 'blueprint configuration overrides' applied to this project."""
  blueprintConfiguration: BlueprintConfiguration

  """
  The 'effective blueprint configuration' is a view of the BlueprintConfiguration that will be used by the Blueprint Driver.
  
  It is the result of merging two BlueprintConfiguration objects:
  1. This project's blueprint.configuration
  2. This project's blueprintConfiguration ("configuration overrides"), if defined.
  """
  effectiveBlueprintConfiguration: BlueprintConfiguration

  """
  Provides a view over driver action executions, grouping together Plan-type
  actions with their Approve and Apply steps (if they exist)
  """
  workflows: [ProjectV3Workflow!] @deprecated(reason: "use 'driverWorkflows' instead")

  """
  Driver workflows submitted for this project.
  NOTE: this field will not surface actions executed via the deprecated 'executeBlueprintDriverAction' mutation.
  """
  driverWorkflows: [BlueprintDriverWorkflow!]
}

type ProjectV3Adapter {
  """- v0.ProjectAdapterID or v1.ProjectID"""
  id: UUID!
  isDeployV2: Boolean!
  repo: Repo
  projectV3: ProjectV3
  name: String!
  status: ProjectV3AdapterStatus
  billable: Boolean
  project: Project
  projectEnvironment: ProjectEnvironment
  createdAt: Time!
  updatedAt: Time!
}

type ProjectV3AdapterConnection {
  nodes: [ProjectV3Adapter!]!
  totalCount: Int!
  pageInfo: PageInfo!
}

enum ProjectV3AdapterStatus {
  UNKNOWN
  DRAFT
  PAUSED
  INACTIVE
  PENDING_HEALTHY_CLUSTER
  JOB_RUN_STARTING
  JOB_RUN_RUNNING
  JOB_RUN_FAILED
  JOB_RUN_SUCCEEDED
  JOB_RUN_CANCELLED
  JOB_RUN_PENDING_APPROVAL
  DEPLOY_PENDING
  DEPLOY_IN_PROGRESS
  DEPLOY_FAILED
  DEPLOY_SUCCEEDED
  DEPLOY_STOPPED
  DEPLOY_HEALTHY
  DEPLOY_CRASHING
  BUILD_PENDING
  BUILD_IN_PROGRESS
  BUILD_FAILED
  BUILD_SUCCEEDED
  BUILD_ABORTED
  CONTAINER_PULLING
  HEALTH_CHECKING
  NODE_PROVISIONING
}

union ProjectV3Configuration = TerraformProjectV3Configuration | HelmProjectV3Configuration | ManifestProjectV3Configuration

type ProjectV3Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  nodes: [ProjectV3!]!
}

input ProjectV3GitopsInput {
  """- v0.ProjectV3ID"""
  projectID: UUID!
  githubConnectionID: Int!
  githubRepoOwner: String!
  githubRepoName: String!
  githubRepoID: String!
  subdirectoryPath: String
}

"""DEPRECATED: prefer BlueprintDriverWorkflow type instead."""
type ProjectV3Workflow {
  state: JobRunState! @deprecated(reason: "use `status` property instead.")
  status: ProjectV3WorkflowStatus!
  jobs: [BlueprintDriverActionExecution!]
  createdAt: Time!
  updatedAt: Time!
}

enum ProjectV3WorkflowStatus {
  QUEUED
  STARTING
  RUNNING
  FAILED
  SUCCEEDED
  PENDING_APPROVAL
  PENDING_MANUAL_ACTION
  ABORTED
}

type Prometheus {
  url: String!
  user: String
  password: String
  token: String
}

type PrometheusScrape {
  path: String!
  port: Int!
}

input PrometheusScrapeInput {
  path: String!
  port: Int!
}

type Query {
  currentUser: User!
  user(id: ID!): User!
  team(id: UUID, path: String): Team

  """- v0.ProjectID or v1.GroupID"""
  project(id: UUID, path: String): Project
  repo(id: UUID, path: String): Repo
  dockerRepository(image: String!): DockerRepository
  checkPrice(input: CheckPriceInput!): CheckPriceOutput!
  prices: Prices!
  productCatalog: ProductCatalog!
  awsCostByService(awsAccountId: UUID!, where: CostByServiceWhere!): [Cost!]!
  awsCostUsage2(awsAccountId: UUID!, where: CostUsageWhere!): [Cost!]!
  blueprint(id: UUID!): Blueprint
  blueprintsMarketplace: BlueprintsMarketplace
  searchHelmCharts(input: SearchHelmChartsInput!): HelmChartConnection!
  helmRepository(url: String!): HelmRepository!
  template(id: UUID, slug: String, url: String): Template!
  terraformRegistry(url: URL): TerraformRegistry!
}

input ReissueCustomDomainCertificateInput {
  id: UUID!
}

type Release {
  id: UUID!
  logs: Logs
}

input RemoveProbeInput {
  """- v0.RepoID"""
  id: ID!
  readinessProbe: Boolean
  livenessProbe: Boolean
  startupProbe: Boolean
}

input RemoveRepoCustomDomainInput {
  id: UUID!
  domainID: UUID!
}

input RemoveTeamMemberInput {
  id: UUID!
  userID: UUID!
}

input RemoveUserIntegrationInput {
  userID: UUID!
  id: UUID!
}

type Replication {
  region: String!
  replicas: Int
  cluster: Cluster
}

input ReplicationInput {
  region: String!
  replicas: Int!
  clusterID: UUID
}

type Repo {
  """- v0.RepoID"""
  id: ID!
  name: String!
  source: RepoSource!
  appID: String
  enabled: Boolean!
  namespace: String
  useHumanReadableKubernetesName: Boolean
  kappID: String
  clusterDomains: [ClusterDomains!]
  cdns: [CDN!]
  envs: [EnvVar!]
  replication: [Replication!]
  ports: [Port!]
  volumes: [VolumeSpec!]
  secretMounts: [KubernetesSecretMount!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployTimeoutSeconds: Int
  buildMethod: BuildMethod
  buildMethodSuggestions: [BuildMethod!]
  noBuildCache: Boolean
  gitSubmodules: GitSubmodulesType
  kanikoFlags: KanikoFlags
  resources: ContainerResourcesSpec
  buildResources: ContainerResourcesSpec
  branchResources: ContainerResourcesSpec
  serverlessResources: ServerlessResourceSpec
  serverlessRegion: String
  readinessProbe: Probe
  livenessProbe: Probe
  startupProbe: Probe
  autoscaling: Autoscaling
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  staticIP: Boolean
  deployments(first: Int = 10, after: String, input: DeploymentsInput): [Deployment!]
  deployment(id: ID!): Deployment
  branches: [RepoBranch!]
  branch(id: UUID, name: String): RepoBranchV2
  productionBranchV2: RepoBranchV2
  branchesV2(page: PageInput, input: BranchInput): RepoBranchConnection
  productionBranch: String
  productionDeployment: Deployment
  githubRepository: GitHubRepository
  githubIntegration: GitHubRepoIntegration
  gitlabIntegration: GitlabRepoIntegration
  helmChart: HelmChart
  helmValues: String
  terraformVersion: String
  terraformVariables: JSON
  image: String
  collaborators: [ProjectCollaborator!]
  collaboratorInvitations: [ProjectCollaboratorInvitation!]
  free: Boolean
  prometheusScrape: PrometheusScrape
  logShipper: LogShipper
  kubernetesCustomization: KubernetesCustomization
  deployTarget: DeployTarget
  deployType: DeployType
  canDeploy: Boolean
  cluster: Cluster
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  awsIamRole: String
  gcpServiceAccount: String
  deployStrategy: DeployStrategy
  deployService: Boolean
  deployJob: Boolean
  cronJobSchedule: String
  jobRun(id: UUID!): JobRun!
  jobRuns: JobRunConnection
  hasBuildStage: Boolean
  hasDeployStage: Boolean
  alternativeImageTagTemplates: [String!]
  containerRegistry: ContainerRegistry
  databaseProvider: DatabaseProviderType
  databaseEngine: DatabaseEngineType
  databaseVersion: String
  databaseLinks: [DatabaseLink!]!
  linkedProjects: [DatabaseLink!]!
  databaseEnvs: [EnvVar!]!
  disableReason: DisableReason
  datadogApmEnabled: Boolean
  pipelineCluster: Cluster
  defaultIngressDomain: String
  project: Project
  projectEnvironment: ProjectEnvironment
  owner: User!
  createdAt: Time!
  updatedAt: Time!
  buildSpec: ContainerSpec
  cpu: String
  memory: String
  gpu: GPUSpec
  tpu: TPUSpec
  ephemeralStorage: Float
  dedicated: Boolean
  deployBranch: Boolean
  branchIgnore: String
  nodeSelector: JSON
  hostNetwork: Boolean
  clusterIssuerName: String
  path: String!
  fullPath: String!
  deploymentConfiguration(revisionId: UUID, sequenceId: Int): RepoDeploymentConfiguration!
  deploymentConfigurationRevisions(page: PageInput): RepoDeploymentConfigurationConnection!
  bitbucketIntegration: BitbucketRepoIntegration
  manifest: Manifest
  pipelineLinks: [RepoPipelineLink!]
  machines: [Machine!]
}

enum RepoAction {
  DEPLOY
}

input RepoActionInput {
  action: RepoAction!
  setImage: String
}

type RepoBranch {
  id: ID!
  name: String!
  state: String
  updatedAt: Time
  deployments: [Deployment!]
}

type RepoBranchConnection {
  totalCount: Int!
  nodes: [RepoBranchV2!]!
  pageInfo: PageInfo!
}

type RepoBranchV2 {
  id: UUID!
  name: String!
  state: String
  status: String
  environmentSlug: String
  branchSlug: String
  latestDeployment: Deployment
  deployments(page: PageInput): DeploymentConnection
  endpoints: [String!]
  privateEndpoints: [String!]
  loadBalancers: [LoadBalancer!]
  metrics(name: String!): [Metric!]
  image: String
  namespace: String
  kappID: String
  patchedPodSpec: String
  renderPodSpec(patch: String): String
  renderIngress(patch: String): String
  awsLinks: AWSLinks
  gcpLinks: GCPLinks
  repo: Repo
  createdAt: Time!
  updatedAt: Time!
  resources: [CloudResource!]

  """
  This will indicate possible issues with the current configuration, i.e. if the git branch no longer exists.
  This will NOT be used to communicate issues about the status of deployed
  resources, i.e. if builds are failing or the deployment is crashing.
  """
  troubleshooting: Troubleshooting
}

type RepoConnection {
  totalCount: Int!
  nodes: [Repo!]!
  pageInfo: PageInfo!
}

type RepoDeploymentConfiguration implements RevisableEntity {
  revisionMetadata: RevisionMetadata!
  revisionData: JSON!
}

type RepoDeploymentConfigurationConnection implements RevisionConnection {
  totalCount: Int!
  nodes: [RepoDeploymentConfiguration!]!
  pageInfo: PageInfo!
}

enum RepoEvent {
  BUILD_SUCCEEDED
  DEPLOY_SUCCEEDED
}

input RepoFilter {
  status: RepoStatusCriterion
}

input repoFilterInput {
  deploymentStatus: [DeploymentStatus]
}

type RepoGroup {
  id: UUID!
  name: String
  description: String
  selector: LabelSelectors
  repos: [Repo!]
}

type RepoPipelineLink {
  """- v0.RepoID"""
  id: UUID!
  source: Repo!
  sourceEvent: RepoEvent!
  targetGroup: RepoGroup!
  targetAction: RepoAction!
}

input ReposInput {
  first: Int = 10
  after: String
  team: ID
  showDisabled: Boolean = false
}

type RepoSource {
  id: ID!
  type: RepoSourceType!
  name: String!
}

enum RepoSourceType {
  GITHUB
  GITHUB_PUBLIC
  GITLAB
  BITBUCKET
  GIT
  DOCKER
  DOCKER_HUB
  HELM
  TERRAFORM
}

input RepoStatusCriterion {
  value: String
  operator: FilterCriterionOperatorType
}

input ResourceAdapterFilter {
  ids: MultiEntityCriterion
  repoIds: MultiEntityCriterion
  resourceIds: MultiEntityCriterion
  deployableIds: MultiEntityCriterion
  name: StringCriterion
  status: AdapterStatusCriterion
  projectName: StringCriterion
  environmentName: StringCriterion

  """Active=true or Paused=false"""
  active: BooleanCriterion
}

input ResourceBranchInput {
  productionBranch: String
  autoDeployBranch: Boolean
  autoStopBranch: Boolean
  branchIgnore: String
  branchStopIgnore: String
}

input ResourceBuildInput {
  build: ProjectBuildInput
  buildTarget: BuildTargetInput
  buildResources: ContainerResourcesSpecInput
  gitSubmodules: GitSubmodulesType
  kanikoFlags: KanikoFlagsInput
  noBuildCache: Boolean
  containerRegistryID: UUID
  containerCacheRepository: String
  containerRepository: String
}

input ResourceDatabaseInput {
  deployTarget: DatabaseDeployTargetInput!
  engine: DatabaseEngineType!
  version: String!
  options: DatabaseOptions
}

input ResourceFilter {
  ids: MultiEntityCriterion
  deployableIds: MultiEntityCriterion
  userIds: MultiEntityCriterion
}

input ResourceKubernetesAppInput {
  useHumanReadableName: Boolean
  deployJob: Boolean
  deployService: Boolean
  releaseCommand: String
  envs: [EnvVarInput!]
  runCommand: String
  volumes: [VolumeInput!]
  secretMounts: [KubernetesSecretMountInput!]
  ports: [PortInput!]
  defaultIngressDomain: String
  staticIP: Boolean
  resources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  replication: [ReplicationInput]
  autoscaling: AutoscalingInput
  logShipper: LogShipperInput
  datadogApmEnabled: Boolean
  prometheusScrape: PrometheusScrapeInput
  deployStrategy: DeployStrategy
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  awsIamRole: String
  gcpServiceAccount: String
  customization: KubernetesCustomizationInput
}

input ResourceKubernetesHelmInput {
  releaseName: String
  values: YAML
  valuesFiles: [String]
}

input ResourceKubernetesInput {
  deployTarget: ProjectDeployInput
  namespace: String
  app: ResourceKubernetesAppInput
  manifest: ResourceKubernetesManifestInput
  helm: ResourceKubernetesHelmInput
}

input ResourceKubernetesManifestInput {
  manifestValue: YAML
  manifests: [String]
  kustomizeDirs: [String]
}

input ResourceServerlessInput {
  deployService: Boolean
  deployTarget: ProjectDeployInput
  envs: [EnvVarInput]
  ports: [PortInput!]
  serverlessResources: ServerlessResourcesSpecInput
}

input ResourceTerraformInput {
  deployTarget: ProjectDeployInput
  variables: JSON
}

enum ResourceType {
  CONTAINER
  POD
  JOB
  DEPLOYMENT
  REPLICASET
  STATEFULSET
  DAEMONSET
  SERVICE
}

input ResourceWorkflowInput {
  autoRetry: Boolean
  autoRollback: Boolean
  manualDeploy: Boolean
  pipelineClusterID: UUID
  deployTimeoutSeconds: Int
}

interface RevisableEntity {
  revisionMetadata: RevisionMetadata!
  revisionData: JSON!
}

interface RevisionConnection {
  totalCount: Int!
  pageInfo: PageInfo!
}

type RevisionMetadata {
  id: UUID!
  description: String!
  sequenceId: Int!
  createdBy: User!
  createdAt: Time!
}

type RightSizingInstance {
  name: String
  monthlyCost: String
  hourlyCost: String
  type: String
  memory: String
  storage: String
  vcpu: String
  utilization: RightSizingUtilization
  resourceId: String
}

type RightSizingRecommendation {
  currentInstance: RightSizingInstance
  recommendations: [RightSizingRecommendationDetail!]
  reasons: [String!]!
}

type RightSizingRecommendationDetail {
  estimatedMonthlyCost: String
  estimatedMonthlySavings: String
  platformDifferences: [String]
  instance: RightSizingInstance
}

type RightSizingUtilization {
  maxCpuUtilizationPercentage: String
  maxMemoryUtilizationPercentage: String
  maxStorageUtilizationPercentage: String
}

input RunJobInput {
  id: UUID!
  runCommand: String
  envs: [EnvVarInput!]
  build: Boolean
}

union Runtime = CloudRuntime | KubernetesRuntime

input S3BucketBackendInput {
  awsAccountID: UUID!
  region: String!
  bucketName: String!
  key: String
}

type S3BucketConfiguration {
  awsAccountID: UUID!
  region: String!
  bucketName: String!
  key: String
}

enum SavingsPlanPaymentOption {
  NO_UPFRONT
  PARTIAL_UPFRONT
  ALL_UPFRONT
  LIGHT_UTILIZATION
  MEDIUM_UTILIZATION
  HEAVY_UTILIZATION
}

type SavingsPlanRecommendation {
  currentOnDemandSpend: String
  estimatedSavingsAmount: String
  estimatedSavingsPercentage: String
  estimatedOnDemandCostWithCurrentCommitment: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
  details: [SavingsPlanRecommendationDetail!]
}

type SavingsPlanRecommendationDetail {
  instanceFamily: String
  offeringId: String
  region: String
  currentAverageHourlyOnDemandSpend: String
  estimatedAverageUtilization: String
  upfrontCost: String
  hourlyCommitmentToPurchase: String
  estimatedMonthlySavingsAmount: String
}

input SavingsPlanRecommendationsInput {
  paymentOption: SavingsPlanPaymentOption!
  type: SavingsPlanType!
  term: SavingsPlanTerm!
}

enum SavingsPlanTerm {
  ONE_YEAR
  THREE_YEARS
}

enum SavingsPlanType {
  COMPUTE_SP
  EC2_INSTANCE_SP
  SAGEMAKER_SP
}

input SearchHelmChartsInput {
  first: Int
  after: String
  query: String
}

type ServerlessConfig {
  service: String
  provider: ServerlessProvider
  functions: [ServerlessFunction!]
  awsStackName: String
}

type ServerlessFunction {
  name: String!
  handler: String
}

type ServerlessProvider {
  name: String
  runtime: String
  stage: String
  region: String
  stackName: String
}

type ServerlessResourceSpec {
  cpu: Float
  memory: Float
}

input ServerlessResourcesSpecInput {
  cpu: Float
  memory: Float!
}

input SetRepoEnvsInput {
  id: ID!
  envs: [EnvVarInput!]!
}

input SignInWithWeb3Input {
  challengeId: UUID!
  signature: String!
}

type SlackIntegration implements Integration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
}

type SlackWebhookIntegration implements Integration & NotificationIntegration {
  id: UUID!
  type: IntegrationType!
  name: String!
  description: String!
  image: String!
  createdAt: Time!
  updatedAt: Time!
  url: String
  notificationSettings: NotificationIntegrationSettings
  deliveryError: NotificationDeliveryError
}

enum SortDirection {
  ASC
  DESC
}

input SortInput {
  direction: SortDirection
  field: String
}

type Source {
  git: GitSource
  terraformRegistry: TerraformRegistrySource
  helmRepository: HelmRepositorySource
  containerRegistry: ContainerRegistrySource
}

input SourceInput {
  git: GitSourceInput
  terraformRegistry: TerraformRegistrySourceInput
  helmRepository: HelmRepositorySourceInput
  containerRegistry: ContainerRegistrySourceInput
}

input StringCriterion {
  value: String
  operator: FilterCriterionOperatorType
}

type StripePrice {
  id: ID!
  product: StripeProduct!
  unitAmount: Int!
}

type StripeProduct {
  id: ID!
  name: String!
  description: String!
}

type StripeSubscription {
  id: ID!
  status: StripeSubscriptionStatus!
  items: [StripeSubscriptionItem!]!
  createdAt: Time!
}

type StripeSubscriptionItem {
  id: ID!
  price: StripePrice!
  quantity: Int!
}

enum StripeSubscriptionStatus {
  active
  past_due
  unpaid
  canceled
  incomplete
  incomplete_expired
  trialing
}

type StripeUser {
  id: ID!
  balance: Int!
}

type Subscription {
  repoUpdated(id: UUID!): Repo!
  deploymentUpdated(id: ID!): Deployment!
  deploymentBuildLogsAdded(input: BuildLogsInput!): LogEntry!
}

input SubscriptionCart {
  planTierSku: ID!
  projectPackSku: ID!
  supportTierSku: ID!
  apiAccessSku: ID!
}

type SubscriptionFeature {
  key: FeatureKey!
  enabled: Boolean
}

type SubscriptionFeatures {
  """Query a specific subscription feature"""
  byKey(featureKey: FeatureKey!): SubscriptionFeature
}

"""
A preview of the desired changes to a subscription.

All fields should be checked for errors: if any errors are returned, a subsequent purchaseSubscription mutation would fail.
"""
type SubscriptionPurchasePreview {
  """
  A short name indicating the payment method on file that will be used for this subscription.
  If no payment method is on file, this will be null.
  If no payment method is on file, _and_ one is required to complete the purchase, an error will be returned."
  """
  paymentMethodName: String
  products: [ProductPurchasePreview!]
}

type SubscriptionPurchaseResponse {
  """The new billing overview with the updated subscription"""
  overview: BillingOverview!
}

"""
Indicates if the team is able to create new entities within their subscription limits.
"""
type SubscriptionUsageAllowed {
  seats: Boolean!
  clusters: Boolean!
  cloudAccounts: Boolean!
  projects: Boolean!
  customBlueprints: Boolean!
}

input SuggestProjectNameInput {
  name: String
  type: String
}

input SuggestTemplateNameInput {
  id: ID!
  name: String
}

type SupportTier implements Product {
  name: String
  description: String
  sku: ID!
  displayPrice: String
  items: Object
  usage: [Usage!]!
  benefits: [String!]!
  productTypeMetadata: ProductTypeMetadata
}

type SyslogIntegration {
  host: String!
  port: String!
  mode: String!
}

input SyslogIntegrationInput {
  host: String!
  port: String!
  mode: String!
}

type TCPProbe {
  host: String
  port: String!
}

type Team implements ProfileOwner & ProjectOwner {
  id: UUID!
  login: Login!
  name: String!
  avatar: URL
  user: User!
  awsAccounts: [AWSAccount!]
  parent: Team
  children: [Team!]
  members: [UserTeamEdge!]!
  memberInvitations: [TeamMemberInvitation!]!
  projects(input: ProjectsInput): ProjectConnection!
  plan: Plan!
}

type TeamMemberInvitation {
  id: UUID!
  team: Team!
  role: TeamMemberRole!
  link: String!
  email: String
  expiresAt: Time
  createdAt: Time!
}

enum TeamMemberRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

type Template {
  id: ID!
  name: String!
  description: String!
  image: String!
  homepageURL: String
  repositoryURL: String
  stats: TemplateStats
  projects: [ProjectTemplate!]!
}

type TemplateStats {
  deploys: Int!
  forks: Int!
  stars: Int!
}

"""Input values for Terraform APPLY actions"""
input TerraformApplyActionParameters {
  """Zeet ID for the driver action execution of a Terraform PLAN action"""
  planID: UUID!
}

"""Input values for Terraform APPROVE actions"""
input TerraformApproveActionParameters {
  """Zeet ID for the driver action execution of a Terraform PLAN action"""
  planID: UUID!
}

type TerraformAutomaticOutputConfiguration {
  """
  Disable the 'automatic output' handler, which produces a single map named 'outputs' containing all module outputs.
  """
  disabled: Boolean

  """
  Mark the automatic output value as sensitive. This is required to be 'true'
  when 'disabled' is false and any sensitive module output is not in 'excluded'.
  """
  sensitive: Boolean

  """
  The keys of any module outputs that should be excluded from the automatic output value. Ignored when 'disabled' is true.
  """
  excluded: [String!]
}

"""See TerraformAutomaticOutputConfiguration."""
input TerraformAutomaticOutputConfigurationInput {
  disabled: Boolean
  sensitive: Boolean
  excluded: [String!]
}

type TerraformClusterComponentMetadata {
  jobRunState: JobRunState
}

type TerraformModule {
  id: ID!
  owner: String
  namespace: String
  name: String
  version: String
  provider: String
  description: String
  source: String
  publishedAt: Time
  downloads: Int
  verified: Boolean
  registry: TerraformRegistry!
}

type TerraformModuleConnection {
  totalCount: Int!
  nodes: [TerraformModule!]!
  pageInfo: PageInfo!
}

type TerraformModuleSource {
  """
  Any valid Terraform Module source: https://developer.hashicorp.com/terraform/language/modules/sources
  """
  source: String!

  """The version field is only applicable to Terraform Registry sources"""
  version: String

  """
  Configuring an integration provides authentication to retrieve the module from private sources
  """
  integration: TerraformModuleSourceIntegration
}

input TerraformModuleSourceInput {
  source: String!
  version: String
  integration: TerraformModuleSourceIntegrationInput
}

type TerraformModuleSourceIntegration {
  git: GitSourceIntegration
}

input TerraformModuleSourceIntegrationInput {
  git: GitSourceIntegrationInput
}

type TerraformOperation {
  id: UUID!
  state: TerraformOperationState!
  approved: Boolean!
  config: JSON
  planStage: PipelineStage
  applyStage: PipelineStage
}

enum TerraformOperationState {
  PENDING
  PLANNING
  WAITING_FOR_APPROVAL
  APPLYING
  PLAN_FAILED
  APPLY_FAILED
  CANCELED
  SUCCEEDED
}

type TerraformOutputConfiguration {
  """
  Configuration for the automatic output handler. This configuration does not affect output defined via 'customization'.
  """
  automatic: TerraformAutomaticOutputConfiguration

  """
  A JSON object using Terraform configuration syntax
  (https://developer.hashicorp.com/terraform/language/syntax/json), constituting
  a valid "output" block.
  
  Example:
  ```
  {
    "output": {
      "example": {
        "value": "${aws_instance.example}"
      }
    }
  }
  ```
  
  This must include the output block "envelope".
  
  To reference module values, use the expression mapping syntax: https://developer.hashicorp.com/terraform/language/syntax/json#expression-mapping
  """
  customization: JSON
}

"""See TerraformOutputConfiguration."""
input TerraformOutputConfigurationInput {
  automatic: TerraformAutomaticOutputConfigurationInput
  customization: JSON
}

"""
[DEPRECATED] Input values for Terraform PLAN actions.
Provider should be configured for the project, i.e. TerraformProjectV3ConfigurationInput,
When the project has a provider configured, these action parameters will be rejected.

This input is deprecated, and will not be supported for executing Plan actions in the v1 API.
"""
input TerraformPlanActionParameters {
  """Zeet ID for a connected AWS Account"""
  awsAccountID: UUID

  """Zeet ID for a connected GCP Account"""
  gcpAccountID: UUID

  """Zeet ID for a connected DigitalOcean Account"""
  doAccountID: UUID

  """Region name, when applicable"""
  region: String
}

"""
[DEPRECATED] Input values for Terraform PLAN_DESTROY actions.
Provider should be configured for the project, i.e. TerraformProjectV3ConfigurationInput,
When the project has a provider configured, these action parameters will be rejected.

This input is deprecated, and will not be supported for executing Plan actions in the v1 API.
"""
input TerraformPlanDestroyActionParameters {
  """Zeet ID for a connected AWS Account"""
  awsAccountID: UUID

  """Zeet ID for a connected GCP Account"""
  gcpAccountID: UUID

  """Zeet ID for a connected DigitalOcean Account"""
  doAccountID: UUID

  """Region name, when applicable"""
  region: String
}

type TerraformProjectV3Configuration {
  moduleName: String
  stateBackend: TerraformStateBackend!
  provider: TerraformProvider
}

input TerraformProjectV3ConfigurationInput {
  moduleName: String
  stateBackend: TerraformStateBackendInput!

  """
  Terraform Provider configuration: Maps a zeet-connected cloud account to a terraform provider.
  This parameter is optional for backwards compatibility. New Projects should specify their provider at creation,
  instead of specifying the provider for each PLAN/PLAN_DESTROY action.
  
  This parameter will be required in the v1 API, and specifying provider "per-plan" will not be supported.
  """
  provider: TerraformProviderInput
}

"""
The Zeet-connected cloud account which will be mapped to a terraform provider
"""
type TerraformProvider {
  awsAccount: AWSAccount
  gcpAccount: GCPAccount
  doAccount: DOAccount

  """Region name, when applicable"""
  region: String
}

input TerraformProviderInput {
  """Zeet ID for a connected AWS Account"""
  awsAccountID: UUID

  """Zeet ID for a connected GCP Account"""
  gcpAccountID: UUID

  """Zeet ID for a connected DigitalOcean Account"""
  doAccountID: UUID

  """Region name, when applicable"""
  region: String
}

type TerraformRegistry {
  id: ID!
  url: URL
  module(id: ID!): TerraformModule!
}

type TerraformRegistrySource {
  source: String!
  version: String
}

input TerraformRegistrySourceInput {
  source: String!
  version: String
}

type TerraformStateBackend {
  """DEPRECATED."""
  awsAccount: UUID

  """DEPRECATED."""
  gcpAccount: UUID

  """DEPRECATED."""
  region: String
  s3Bucket: S3BucketConfiguration
  gcsBucket: GCSBucketConfiguration
}

input TerraformStateBackendInput {
  s3Bucket: S3BucketBackendInput
  gcsBucket: GCSBucketBackendInput
}

scalar Time

enum TimeFilter {
  Monthly
  Daily
}

type TimePeriod {
  startAt: Time!
  endAt: Time!
}

input TPUInput {
  type: String!
  cores: Int!
  tfVersion: String!
}

type TPUSpec {
  tfVersion: String!
  type: String!
  cores: Int!
}

input TransferProjectInput {
  id: ID!
  to: ID!
}

"""
A minimal representation of some error state, and some possible triage, when available.
"""
type Troubleshooting {
  """
  The headline issue currently outstanding for this troubleshooting's parent object.
  """
  issue: TroubleshootingIssue
}

type TroubleshootingIssue {
  """
  Zero or more blocks representing either evidence of an issue or corresponding user instructions
  """
  blocks: [TroubleshootingIssueBlock!]
  issueCode: String
}

type TroubleshootingIssueBlock {
  blockType: TroubleshootingIssueBlockType
  content: String
}

enum TroubleshootingIssueBlockType {
  INSTRUCTION
  EVIDENCE
}

input UpdateAWSAccountInput {
  id: UUID!
  name: String
}

input UpdateAzureAccountInput {
  id: UUID!
  name: String
  subscriptionID: String
  tenantID: String
  clientID: String
  clientSecret: String
}

input UpdateBitbucketIntegrationInput {
  userID: UUID!
  id: UUID!
  name: String
  accessToken: String
}

input UpdateBlueprintInput {
  displayName: String
  published: Boolean
  slug: String
  configuration: BlueprintConfigurationUpdate

  """
  Update the variables. Supports partial updates: only specify the variables that you wish to update.
  To modify or remove an existing variable, you must specify the variable's ID.
  
  If ID is not present, the variable will be created (and the "remove" field will be ignored).
  """
  variables: [BlueprintVariableSpecUpdate!]
  richInputSchema: JSON
  description: String
  tags: [String!]
  logoUrl: String
  outputSchema: BlueprintOutputSchema
  connectorSchema: ProjectConnectorSchema
}

input UpdateBranchInput {
  id: UUID
  repoID: UUID
  name: String
  image: String
  githubSha: String
  build: Boolean
  deploy: Boolean
}

input UpdateCDNInput {
  id: UUID!
  domains: [String!]
}

input UpdateClusterAddOn {
  slug: String!
  state: ClusterAddOnState!
  helmValues: YAML
}

input UpdateClusterDomainInput {
  domain: String!
  clusterID: UUID!
}

input UpdateClusterInput {
  id: UUID!
  kubeconfig: Upload
  name: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID

  """
  The new configuration for cluster add-ons. When this field is provided (i.e. not-null), it must include
  _all_ cluster add-ons present in `Cluster.addOns`, even if some of the add-ons are not being modified.
  
  This is because once an add-on is added to a cluster, it cannot be _removed_, only _disabled_.
  """
  addOns: [UpdateClusterAddOn!]
}

input UpdateCoreWeaveAccountInput {
  id: UUID!
  name: String
}

input updateDatabaseLinkInput {
  id: UUID!
  envPrefix: String
}

input UpdateDOAccountInput {
  id: UUID!
  name: String
  accessToken: String
}

input UpdateGCPAccountInput {
  id: UUID!
  name: String
}

input UpdateGitlabIntegrationInput {
  userID: UUID!
  id: UUID!
  name: String
  apiUrl: URL
  accessToken: String!
}

input UpdateIPFSServiceInput {
  id: UUID!
  accessToken: String
}

input UpdateLinodeAccountInput {
  id: UUID!
  name: String
  accessToken: String
}

input UpdateMarketplaceBlueprintInput {
  userID: UUID!
  blueprintID: UUID!
  enabled: Boolean
}

input UpdateProjectDangerInput {
  """- v0.RepoID"""
  id: UUID!
  namespace: String
  appID: String
  defaultIngressDomain: String
  useHumanReadableKubernetesName: Boolean
  deployTarget: ProjectDeployInput
}

input UpdateProjectEnvironmentInput {
  id: UUID!
  name: String
  redeployRepoIDs: [UUID!]
  envs: [EnvVarInput!]
}

input UpdateProjectInput {
  """- v0.RepoID"""
  id: ID!
  path: String
  name: String
  dockerImage: String
  githubIntegration: GitHubRepoIntegrationInput
  gitlabIntegration: GitlabRepoIntegrationInput
  buildType: String
  dockerfilePath: String
  dockerfileText: String
  workingDirectory: String
  buildCommand: String
  runCommand: String
  staticPath: String
  releaseCommand: String
  nodejsVersion: String
  pythonVersion: String
  golangVersion: String
  noBuildCache: Boolean
  gitSubmodules: GitSubmodulesType
  kanikoFlags: KanikoFlagsInput
  alternativeImageTagTemplates: [String!]
  volumes: JSON
  ports: JSON
  replication: [ReplicationInput!]
  resources: ContainerResourcesSpecInput
  buildResources: ContainerResourcesSpecInput
  branchResources: ContainerResourcesSpecInput
  serverlessResources: ServerlessResourcesSpecInput
  readinessProbe: ProbeInput
  livenessProbe: ProbeInput
  startupProbe: ProbeInput
  autoscaling: AutoscalingInput
  preStopSleep: Int
  terminationGracePeriodSeconds: Int
  prometheusScrape: PrometheusScrapeInput
  hostNetwork: Boolean
  staticIP: Boolean
  iamPolicies: [String!]
  manualDeploy: Boolean
  autoRetry: Boolean
  autoRollback: Boolean
  deployStrategy: DeployStrategy
  deployTimeoutSeconds: Int
  helmVersion: String
  helmValues: String
  terraformSource: String
  terraformVersion: String
  terraformVariables: String
  manifests: [String!]
  manifestValue: String
  manifest: ResourceKubernetesManifestInput
  awsIamRole: String
  gcpServiceAccount: String
  clusterIssuerName: String
  logShipper: LogShipperInput
  deployService: Boolean
  deployJob: Boolean
  cronJobSchedule: String
  productionBranch: String
  containerRepository: String
  containerCacheRepository: String
  containerRegistryID: UUID
  nodeSelector: JSON
  secretMounts: [KubernetesSecretMountInput!]
  kubernetesCustomization: KubernetesCustomizationInput
  buildCPU: Float
  buildMemory: Float
  cpu: String
  memory: String
  ephemeralStorage: Float
  gpu: GPUInput
  tpu: TPUInput
  dedicated: Boolean
  githubInstallationID: String
  githubRepository: String
  deployBranch: Boolean
  branchIgnore: String
  datadogApmEnabled: Boolean
  pipelineClusterID: UUID
  deployTarget: ProjectDeployInput
}

input UpdateProjectV2Input {
  id: UUID!
  name: String
  envs: [EnvVarInput!]
}

input UpdateProjectV3Input {
  name: String
  requirePlanApproval: Boolean
  variables: [BlueprintVariableInput!]

  """- v0.ProjectID or v1.GroupID"""
  projectID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  environmentID: UUID

  """
  Blueprint configuration overrides to apply to the project, or the configuration if this project is based on
  a sourceless blueprint. If set to null, the configuration will be cleared. If omitted, no changes occur.
  Otherwise, a partial PATCH update will be performed.
  """
  blueprintConfiguration: BlueprintConfigurationInput
  terraformConfiguration: TerraformProjectV3ConfigurationInput
  manifestConfiguration: ManifestProjectV3ConfigurationInput
  helmConfiguration: HelmProjectV3ConfigurationInput
}

input UpdateRepoCustomDomainInput {
  id: UUID!
  disableCertManager: Boolean
  certManagerChallengerType: CertManagerChallengeType
  syncDomainID: UUID
}

input UpdateRepoPipelineLinkInput {
  """- v0.RepoID"""
  id: UUID!
  sourceEvent: RepoEvent
  targetRepoID: UUID

  """- v0.EnvironmentID or v1.SubGroupID"""
  targetEnvironmentID: UUID
  targetAction: RepoAction
}

input UpdateResourceAlphaInput {
  source: SourceInput
}

input UpdateTeamInput {
  id: UUID!
  plan: UpdateTeamPlanInput
  paymentMethod: String
}

input UpdateTeamMemberRoleInput {
  id: UUID!
  role: TeamMemberRole!
}

input UpdateTeamPlanInput {
  tier: PlanTier!
  billingPeriod: PlanBillingPeriod!
}

input UpdateUserInput {
  id: UUID!
  avatar: URL
  login: String
  name: String
  email: String
}

input UpdateVultrAccountInput {
  id: UUID!
  name: String
}

input UpdateWebhookIntegrationInput {
  userID: UUID!
  id: UUID!
  url: String!
}

scalar Upload

scalar URL

"""
If a self-service link is available, url will be non-null. If url is null, notAllowed should be non-null.
"""
type UrlOrContactUs {
  url: URL

  """True if url is a self-service link, false if url is the contact url."""
  hasUrl: Boolean!

  """
  If no self-service link is available, please get in touch with us via this URL.
  """
  contactUrl: URL!
  notAllowed: BillingActionNotAllowed

  """
  When applicable, some help text explaining why a url is or is not available.
  """
  tooltip: String
  contactUs: ContactUs @deprecated(reason: "Use notAllowed instead.")
}

"""A usage indicator"""
type Usage {
  unit: String!
  unitPlural: String!

  """A header display name"""
  displayName: String!

  """When the query is not for a specific user, currentUsage will be null"""
  currentUsage: Int

  """Null indicates unlimited usage allowed"""
  maximumUsage: Int
  description: String
}

type User implements ProfileOwner & ProjectOwner {
  id: ID!
  login: Login!
  name: String!
  avatar: URL
  isTeam: Boolean
  canDeploy: Boolean
  hasZeetCloud: Boolean
  hasOnboarded: Boolean
  advanced: Boolean
  email: String
  billingEmail: String
  createdAt: Time
  hasPaymentMethod: Boolean
  needsPaymentMethod: Boolean @deprecated(reason: "no longer supported: use User.billingOverview.externalLinks instead")
  billingURL: String
  stripe: StripeUser
  freeQuota: Int
  freeTrialEndsAt: Time
  freeLimitExceeded: Boolean
  paymentError: String @deprecated(reason: "no longer used")
  paymentAuthorizationError: String
  teams: [UserTeamEdge!]
  team(id: ID!): Team
  repos(first: Int = 10, after: String, input: ReposInput): [Repo!]
  repo(id: ID!): Repo
  projects(input: ProjectsInput): ProjectConnection!
  deployment(id: ID!): Deployment
  githubInstallations: [GitHubInstallation!]
  githubRepositories(installationID: ID!): [GitHubRepository!]
  githubRepository(installationID: ID!, owner: String!, repo: String!): GitHubRepository
  dockerRepository(image: String!): DockerRepository
  suggestProjectName(input: SuggestProjectNameInput!): String!
  checkProjectName(input: CheckProjectNameInput!): Boolean!
  suggestTemplateName(input: SuggestTemplateNameInput!): String!
  awsAccount(id: UUID!): AWSAccount
  awsAccounts: [AWSAccount!]
  gcpAccount(id: UUID!): GCPAccount
  gcpAccounts: [GCPAccount!]
  doAccount(id: UUID!): DOAccount
  doAccounts: [DOAccount!]
  linodeAccount(id: UUID!): LinodeAccount
  linodeAccounts: [LinodeAccount!]
  vultrAccount(id: UUID!): VultrAccount
  vultrAccounts: [VultrAccount!]
  coreweaveAccount(id: UUID!): CoreWeaveAccount
  coreweaveAccounts: [CoreWeaveAccount!]
  cloudAccount(id: ID!): CloudAccount
  jobRun(id: UUID!): JobRun!
  cluster(id: UUID!): Cluster
  clusters: [Cluster!]
  defaultCluster: Cluster
  apiKeys: [APIKey!]
  containerRegistries: [ContainerRegistry!]
  integrations: [Integration!]
  crispAuth: CrispAuth
  ipfsServices: [IPFSService!]
  azureAccount(id: UUID!): AzureAccount
  azureAccounts: [AzureAccount!]

  """Billing Overview only exists for users with subscriptions, i.e. a team"""
  billingOverview: BillingOverview
  blueprints(page: PageInput): BlueprintConnection
  blueprint(id: UUID!): Blueprint
  projectV3(id: UUID!): ProjectV3
  projectV3s(filter: FilterInput!): ProjectV3Connection
  projectV3DriverActionExecutions(filter: FilterInput!): BlueprintDriverActionExecutionConnection
  blueprintDriverWorkflow(id: UUID!): BlueprintDriverWorkflow
  projectV3Adapters(filter: FilterInput!): ProjectV3AdapterConnection
  eventIntegrations: [EventIntegration!]

  """
  Global settings for notification integrations. These settings may be overriden per-integration.
  """
  notificationIntegrationSettings: NotificationIntegrationSettings
  permissions: UserPermissionsConnection
}

enum UserAction {
  READ_PRIVATE
  EDIT_BILLING
}

type UserAuth {
  authToken: String!
}

input UserFilter {
  ids: MultiEntityCriterion
}

type UserIamConnection {
  userId: String!
  awsIamArn: String!
  awsAccountId: String!
  id: UUID!
}

type UserPermissionsConnection {
  principal: User
  user(userID: UUID!): UserPermissionsUserConnection
}

type UserPermissionsUserConnection {
  user: User
  mutations: [PermissibleMutation!]!
}

type UserTeamEdge {
  id: UUID!
  user: User!
  team: Team!
  role: TeamMemberRole!
}

scalar UUID

enum VariableType {
  STRING
  BOOLEAN
  INTEGER
  FLOAT
}

scalar VariableValueInput

type Volume {
  id: ID!
  spec: VolumeSpec!
}

input VolumeInput {
  mountPath: String!
  size: Int!
}

type VolumeSpec {
  size: Int!
  mountPath: String!
}

type VultrAccount {
  id: UUID!
  name: String!
  state: CloudAccountState!
  accessToken: String
  connected: Boolean
  clusters: [Cluster!]
  projects(input: ProjectsInput): ProjectConnection
  projectV3Adapters: ProjectV3AdapterConnection
  createdAt: Time!
  updatedAt: Time!
  networks: [Network!]
}

type Web3Challenge {
  id: UUID!
  address: String!
  nonce: String!
}

scalar YAML

